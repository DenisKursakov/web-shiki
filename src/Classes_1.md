**Theory**
Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?
**Ответ:** 
1. private
2. default
3. protected
4. public
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 67.
Что является членами класса?
**Ответ:** Класс содержит переменные и методы, которые называются элементами класса, членами класса.
**Источник:** https://www.examclouds.com/ru/java/java-core-russian/oop-klassi-metodi
Что еще можно определить в классе кроме членов?
**Ответ:** Конструктор класса.
**Источник:** https://metanit.com/java/tutorial/3.1.php
Какие уровни доступа есть у членов класса?
**Ответ:**
1. private — члены класса доступны только членам данного класса; 
   по умолчанию (package-private) — члены класса доступны классам, находящимся в том же пакете;
2. protected — члены класса доступны классам, находящимся в том же пакете,
   и подклассам — в других пакетах;
3. public — члены класса доступны для всех классов в этом и других пакетах.
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 68.
Какие модификаторы необходимы для определения константы:
1. класса,
2. экземпляра класса?
**Ответ:** Модификатор final используется для определения констант.
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 68.
Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
   class SomeClass {
   private int a; 
   private static int c; 
   private static final int D; 
   private final int b; 
   ...
   }
Как можно назвать данные поля в зависимости от комбинации модификаторов
static и final?
**Ответ:**
   private int a; //class instance variable - Приватное поле класса. 
   private final int b; // class instance static variable - Приватное константное поле класса. 
   private static int c; // class static final variable - Статическое поле класса
   private static final int D; // class instance final variable - Константное, статическое поле класса    
Может ли класс не иметь ни одного конструктора? Почему?
**Ответ:** Если конструктор явно не прописывать, класс может быть реализован. Т.к. по умолчанию каждый класс создает себе дефолтный (пустой, невидимый) конструктор.
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 69.
Перечислите отличия конструктора от метода.
**Ответ:** 
1. Конструктор не возвращает значение
2. Имя конструкторо должно совпадать с именем класса в котором конструктор создан
3. Конструктор вызывается только при использовании ключевого слова new
4. Конструктор не может быть объявлен как static, final, abstract, synchronized,
   native.
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 72.
Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же
класса?
**Ответ:**  В первой строке конструктора, можно прописать с помощью ключевого слова this(parameters)
**Источник:** 
Как и в каком месте можно вызвать конструктор суперкласса?
**Ответ:** Конструктор подкласса при его создании всегда наделяется возможностью
   вызова конструктора суперкласса. Этот вызов может быть явным или неявным и располагается только в первой строке кода конструктора подкласса.
   Если конструктору суперкласса нужно передать параметры, то необходим
   явный вызов из конструктора подкласса super(parameters).
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 69-70.
Что делает компилятор, если в конструкторе нет вызова другого конструктора или
конструктора суперкласса?
**Ответ:** Выполнит собственный код, без унаследования параметров других конструкторов.
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 72
Можно ли одновременно использовать конструкции this() и super() в одном и том
же конструкторе?
Обоснуйте ответ.
**Ответ:** Нельзя, так как конструкции this() и super() внутри конструктора должны находиться выше остальных выражений, соотвественно одна из конструкций не будет соответвовать этому требованию.
**Источник:** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java 
Может ли быть приватный уровень доступа у конструктора? Если да, то для каких
целей он необходим?
**Ответ:** Может, он необходим для того, что бы к конструктору класса мог получить доступ только код внутри данного класса. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.
**Источник:** javarush.ru
Какие модификаторы может иметь конструктор?
**Ответ:** Конструктор может объявляться только со спецификаторами видимости:
   public, private, protected или по умолчанию
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 70
Конструктор принадлежит классу или экземпляру класса?
**Ответ:** Конструктор принадлежит объекту и создается с помощью ключевого слова new.
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 69
Можно ли наследовать конструктор?
Если да, то приведите примеры.
**Ответ:** Подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса. в Java конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть вызван из подкласса.
**Источник:** http://proglang.su/java/inheritance
Какой тип возвращаемого конструктором значения?
**Ответ:** Конструктор не имеет тип возращаемого значения
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 69-70.
Дан класс.
class Null {
//фрагмент 1
Null Null() {
return null;
}
//фрагмент 2
Null() {
return null;
}
}
В каком фрагменте ошибка компиляции?
Удалите этот фрагмент полностью.
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.
**Ответ:**
   class Null {
   //фрагмент 1
   Null Null() {  //Создаем метод(без параметров) с типом возвращаемого значения Null
   return null;   //Метод возвращает null;
   }
   }

Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где
метод, а где конструктор (см. пример выше)?
**Ответ:** Название метода именем класса является грубым нарушением соглашения о написании кода. 
Метод вызываетя при обращению к классу или экземпляру класс, а конструктор при помощи слова new.
Так же конструктор не имеет возвращаемого значения.
**Источник:**
Дан класс.
class Name {
String name;
Name() {
this(makeRandomName());
}
Name(String name) {
super();
this.name = name;
}
String makeRandomName() {
int k = (int) (Math.random() * 3);
String name = new String[] {"Alpha", "Beta",

"Gamma"}[k];

return name;
}
public String toString() {
return name;
}
public static void main(String[] args) {
System.out.println(new Name());
}
}
Объясните причину ошибки компиляции.
Предложите минимум 2 способа исправления ошибки, использовать метод
makeRandomName() обязательно.
**Ответ:** 
1. Можно сделать метод статическим.
2. Можно вынести метод в отдельный утилитный класс и так же сделать его статическим.
Дан класс.
class Int {
int i;
void inc(Int param) {
//param = new Int();
param.i++;
}
public static void main(String[] args) {
Int obj = new Int();
obj.inc(obj);
System.out.println(obj.i);
}
}
Изменится ли результат, если убрать комментарий?
Объясните, почему?
**Ответ:** Если убрать комментарий, то создается новый инт объект, и значение этого объетка увеличено на 1. А агрумент передающийся в метод будет тот же.
**Источник:**
В чем смысл конструкции this?
**Ответ:** Операции с полями класса внутри логического блока до
явного объявления этого поля возможны только при использовании ссылки
this, представляющей собой ссылку на текущий объект.
**Источник:** JAVA FROM EPAM. И.Н. Блинов, В.С. Романчик стр. 86
Перечислите случаи, когда используется конструкция this.
**Ответ:**
1.Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена;
2.Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого. Это еще называется явным вызовом конструктора.
**Источник:** https://javarush.ru/groups/posts/608-kljuchevoe-slovo-this-v-primerakh
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими
возможностями. Если можно, то каким образом?
**Ответ:** 
**Источник:**
Можно ли присвоить null ссылочной переменной this?
**Ответ:** Нет, т.к. ключевое слово this используется в уже существующем экземпляре, который соотвественно не может быть null;
**Источник:** Форум https://coderoad.ru/
Перечислите случаи, когда используется статический блок?
**Ответ:** На практике статические логические блоки могут применяться для проверки
и инициализации базовых параметров, необходимых для функционирования
приложения или класса
**Источник:** И.Н. Блинов. стр. 86
В каких случаях можно обойтись без него. Если можно, то каким образом?
**Ответ:** Статический блок используется для инициализации статических переменных, а "обычный"  - для всех остальных.
**Источник:** 
Перечислите случаи, когда используется логический блок?
**Ответ:** Логические блоки чаще всего используются в качестве инициализаторов
полей, но могут содержать вызовы методов и обращения к полям текущего
класса.
**Источник:** И.Н. Блинов стр. 86
В каких случаях можно обойтись без него. Если можно, то каким образом?
**Ответ:** 
**Источник:**
Что входит в сигнатуру метода?
**Ответ:** Имя метода и параметры.
**Источник:** Герберт Шилдт.
Что значит ключевое слово native?
**Ответ:** native-это ключевое слово в java , которое используется для того, чтобы сделать нереализованную структуру(метод) похожей на абстрактную, 
но она будет зависеть от платформы, такой как собственный код, и выполняться из собственного стека, а не из стека java.
**Источник:** Форум https://coderoad.ru/
Дан код.
public class BusinessTrip {
...
public String bynToStr(int value) {
return (value / 100) + "." + (value / 10 % 10) + (value % 10);
}
}
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте.
Дан код.
public class Utility {
private Utility() {
}
public String bynToStr(int value) {
return (value / 100) + "." + (value / 10 % 10) + (value % 10);
}
}
Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты.
К каким данным можно обратиться в статическом методе?
**Ответ:** Статические поля и методы не могут обращаться к нестатическим полям и методам напрямую, 
так как они не «знают», к какому объекту относятся, да и сам экземпляр класса может быть не создан
**Источник:** И. Блинов Java from Epam стр. 81

Почему нельзя объявить статическое поле внутри метода?

Перечислите, какой код в классе можно выполнить до создания объекта.
Ответ. Статические методы, статические блоки
Источник. И. Блинов Java from Epam стр. 81


В чем различие между объектом и экземпляром класса?
**Ответ:** Экземпляр класса и объект означают одно и то же и часто могут использоваться взаимозаменяемо
**Источник:** https://coderoad.ru/2885385/В-чем-разница-между-экземпляром-и-объектом
Почему нельзя объявить статическое поле внутри метода?
**Ответ:** Статические поля можно объявлять только в начале класса, т.к. они выполняются до выполнения метода

Назовите три этапа создания экземпляра класса.
**Ответ:** Объект класса создается за два шага. Сначала объявляется ссылка на объект
класса. Затем с помощью оператора new создается экземпляр объекта.
**Источник:** И.Н.Блинов стр 11.
Охарактеризуйте отношение композиции между классами? Как оно реализуется?
**Ответ:** Композиция имеет жёсткую зависимость времени существования экземпляров класса контейнера и экземпляров содержащихся классов. 
Если контейнер будет уничтожен, то всё его содержимое будет также уничтожено.
**Источник:** javarush.ru
Допустим, необходимо, чтобы метод возвращал два значения одного примитивного
типа. 
Предложите способы и подтвердите примерами.
**Ответ:** Метод может возвращать массив нужного типа данных. Так же можно создать класс который будет представлять нужное значение и с помощью метода возвращать экземпляр класса.
Примеры: new Pair<Integer>, return int[] array {a,b}; return new Method (a,b);
**Источник:** Форум coderoad.ru
Допустим, необходимо, чтобы метод возвращал два значения разных примитивных
типов.
Предложите способы и подтвердите примерами.
**Ответ:** Объявить класс с соответсвующими полями и возвращать экземпляр, создать массив типа Object;
**Источник:** Форум coderoad.ru
Что такое иммутабельный объект?
**Ответ:** Это объект, который не позволяет изменять свои параметры. 
А если Вы все-же пытаетесь что-то изменить, то получаете новый объект. Но старый останется прежним.
**Источник:** vertex-academy.com
Опишите 2 способа создания иммутабельных объектов.
Подсказка. Способ 1 - класс материала в classes2.
Какой альтернативный?
Подсказка - ключевое слово final для полей не использовать.
**Ответ:**
**Источник:**
Создайте иммутабельный класс для вещества по альтернативному способу.
Даны 2 класса.
final class Material {
private final String name;
private final double density;
...
}
class Runner {
private static void printMaterial(final Material material) {
System.out.println(material);
}
public static void main(String[] args) {
Material steel = new Material("steel",7850);
printMaterial(steel);
}
}
В методе printMaterial() по ссылке material создается новый объект или имеется
доступ к объекту new Material("steel",7850)?
Какой пример можно использовать для обоснования ответа?
Класс для комплексного числа содержит два поля:
class Complex {
private double re;
private double im;
...
}
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
Реализуйте эти же методы при условии, что класс Complex является иммутабельным.
Для чего предназначен метод toString()?
В каких случаях он вызывается?
**Ответ:** toString метод в Java используется для предоставления ясной и достаточной информации об объекта ( Object ) в удобном для человека виде.
Метод можно переопределить что бы выводить информацию, которая будет более уместно описывать объект.
toString вызывается когда нужно получить информацию по объекту. Или же если получить внутренние данные объекта.
**Источник:**
Как реализован метод toString() в классе Object?
**Ответ:** public String toString() {
return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
Поскольку toString() определен в классе java.lang.Object и его реализация по умолчанию не предоставляет много информации, 
всегда лучшей практикой является переопределение данного метода в классе-потомке. По умолчанию реализация toString создает вывод в виде:
Для чего предназначен метод equals()?
В каких случаях он вызывается?
**Ответ:** Метод equals() необходим в Java для подтверждения или отрицания того факта, что два объекта одного происхождения являются логически равными.
Метод вызывается если сравнить нужно ссылочные типы данных.
**Источник:** https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam
Как реализован метод equals() в классе Object?
**Ответ:** 
**Источник:**
В чем различие между методом equals() и операции ==?
**Ответ:** equals() используется для сравнения ссылочных типов данных, в то время как == при сравнении ссылочных переменных будет сравнивать ссылки, а не сами объекты.
**Источник:**
В каких случаях применение метода equals() и операции == эквивалентно?
**Ответ:** В том случае если сравниваемые переменные ссылаются а один объект.
**Источник:**
Eclipse в стандартной конфигурации генерирует начало метода equals() следующим
образом:
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;

С чем связаны данные проверки, которые кажутся лишними?
Что такое garbage collection?
**Ответ:** Garbage Collector (GB) часть JVM, который призван очищать память, выделенную приложению. Он должен:
найти мусор (неиспользуемые объекты)
удалить мусор.
**Источник:** https://ziginsider.github.io/Garbage_Collector_Java/
Перечислите случаи, когда JVM отдает управление на garbage collector.
**Ответ:** Иногда программист может забыть уничтожить бесполезные объекты, и выделенная им память не освобождается. Расходуется все больше и больше системной памяти, и в конечном итоге она больше не выделяется. Такие приложения страдают от “утечек памяти”.
После определенного момента памяти уже не хватает для создания новых объектов, и программа нештатно завершается из-за OutOfMemoryErrors.
Можно сказать, что в любой момент времени память кучи состоит из двух типов объектов.
Живые — эти объекты используются, на них ссылаются откуда-то еще.
Мертвые — эти объекты больше нигде не используются, ссылок на них нет.
Сборщик мусора находит эти неиспользуемые объекты и удаляет их, чтобы освободить память.
**Источник:** https://medium.com/nuances-of-programming
Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?
**Ответ:** лучший вариант-вызвать System.gc() , который просто намекает сборщику мусора, что вы хотите, чтобы он сделал сборку.
**Источник:** https://javarush.com/
Гарантирует ли garbage collector, что приложение в любом случае не будет иметь
проблемы с недостатком памяти?
Обоснуйте ответ.
**Ответ:** Нет, всегда возможно, что вы попытаетесь выделить больше памяти, чем доступно.
Автоматическая сборка мусора означает только то, что мусор (т. е. неиспользуемая память) автоматически собирается (т. е. утилизируется для дальнейшего использования). Если вы сохраняете ссылки на него, это не мусор и не собирается.
**Источник:** Форум https://coderoad.ru/2097461/
Для чего предназначен метод finalize()?
**Ответ:** Если объект взаимодействует с какими-то ресурсами, например открывает поток вывода и читает из него, то такой поток необходимо закрыть перед удалением объекта из памяти. 
Для этого в языке Java достаточно переопределить метод finalize(), который вызывается в исполняющей среде Java непосредственно перед удалением объекта данного класса.
**Источник:** https://www.examclouds.com/ru/java/java-core-russian/metod-finalize
Какой недостаток у метода?
**Ответ:** Метод finalize() не вызывается при выходе объекта из области действия. Заранее неизвестно, когда будет (и будет ли вообще) выполняться метод finalize().
**Источник:** https://www.examclouds.com/ru/java/java-core-russian/metod-finalize
Для чего предназначены оболочечные классы?
**Ответ:** Классы-оболочки Java являются Объектным представлением восьми примитивных типов в Java. Все классы-оболочки в Java являются неизменными и final. 
Начиная с Java 5 автоупаковка и распаковка позволяет легко конвертировать примитивные типы в их соответствующие классы-оболочки и наоборот
**Источник:** https://javadevblog.com
Как они называются на инглише?
**Ответ:** "wrapper" (с англ. "обертка, упаковка").
**Источник:**
В чем преимущество примитивных типов перед соответствующими оболочечными
классами?
**Ответ:** Примитивы и их аналоги, классы оболочки, существуют параллельно, потому что у каждого есть преимущества.
Примитивы занимают меньше места, и если нет необходимости проводить над ними особые операции, Ваш компьютер будет работать быстрее.
**Источник:** https://vertex-academy.com/tutorials/ru/klassy-obolochki-v-java/
Что такое autoboxing и unboxing?
**Ответ:** Autoboxing - это автоматическое преобразование, которое компилятор Java делает между примитивными типами и их соответствующей оберткой объекта классы. 
Например, преобразование int в Integer, двойное к Двойной и т. д. Если преобразование идет другим путем, это называется unboxing.
**Источник:** https://overcoder.net/q/72071/
Дан код:

Integer a = 3, b =7;
Long c = a + b;
Перечислите все операции, где задействованы autoboxing и unboxing.
Дан корректный раннер-класс.
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода
main()?
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?
Дан код:
Integer a = 3, b =7;
Long c = a + b;
Перечислите все операции, где задействованы autoboxing и unboxing.
**ОтветЖ**
a = 3, b =7, a + b – autoboxing
c = - unboxing

Дан корректный раннер-класс.
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()?
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?
**Ответ** Если убрать модификатор static, компилятор будет искать метод с данным модификатором и с аргументом String[] args. При необнаружении такого метода, компилятор выдаст ошибку

Дан класс.
class Runner {
public static void main(String[] args) {
System.out.println("Hello, world!");
}
}
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!
**Ответ:**
class Runner {
static {
System.out.println("I am java.");
}
public static void main(String[] args) {
System.out.println("Hello, world!");
}
}
Бонусное задание 1 (необязательное)
В задаче classes3 имеются два константных поля в классе покупки.
Им сразу присваиваются значения по умолчанию.
Например.
public class Purchase {
public final static String PRODUCT_NAME = "milk";
public final static int PRICE = 120;
...
}
Измените реализацию так, чтобы константы инициализировались значениями из
текстового файла, находящемся в том же пакете, что и класс покупки. Имя файла -
константа в классе покупки.
Если будет сбой с файлом или в нем будут недопустимые значения, то присвойте
константам PRODUCT_NAME и PRICE значения по умолчанию.
Для этого же примера начало класса должно быть таким:
public class Purchase {
private static final String PRODUCT_NAME;
private static final int PRICE;
public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
private static final String DEFAULT_PRODUCT_NAME = "milk";
private static final int DEFAULT_PRICE = 120;