**Theory**

(1) Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?  
**Ответ.**  Модификаторы уровня доступа определяют, могут ли другие классы использовать определенное поле или вызывать определенный метод. Есть два уровня контроля доступа:
На верхнем уровне ``public-`` или ``package-private`` (без явного модификатора).  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html

(2) Что является членами класса?  
**Ответ.** Поля и методы в объявлении класса называются общим словом - члены класса.
Терминология членов класса:
Поля экземпляра
Методы экземпляра
Статические члены
Вложенные классы и вложенные интерфейсы  
**Источник.**  https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.6

(3) Что еще можно определить в классе кроме членов?  
**Ответ.** Конструктор класса, статический блок инициализации класса, блок инициализации экземпляра
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.6


(4) Какие уровни доступа есть у членов класса?  
**Ответ.** ``Public, protected, no modifier, private``  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html


(5) Какие модификаторы необходимы для определения константы:
1. класса,
2. экземпляра класса?  
   **Ответ.**
   1.``static final``
   2.``final``  
   **Источник.**  https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html

(6) Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
 ```java 
    class SomeClass {  
        private int a;  
        private final int b;  
        private static int c;  
        private static final int D;  
        ...
    }
 ```
(7) Как можно назвать данные поля в зависимости от комбинации модификаторов ``static`` и ``final``?  
**Ответ.**
1. Переменная экземпляра класса.
2. Константа экземпляра класса.
3. Переменная класса.
4. Константа класса.
5. **Источник.**  https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html


(8) Может ли класс не иметь ни одного конструктора? Почему?  
**Ответ.** Вам не нужно предоставлять никаких конструкторов для вашего класса, но вы должны быть осторожны при этом.
Компилятор автоматически предоставляет конструктор по умолчанию без аргументов для любого класса без конструкторов. Э
тот конструктор по умолчанию будет вызывать конструктор суперкласса без аргументов. В этой ситуации компилятор будет жаловаться,
если у суперкласса нет конструктора без аргументов, поэтому вы должны убедиться, что он есть. Если класс не имеет никакого явного суперкласса,
то есть неявный суперкласс ``Object``, который имеет конструктор без аргументов  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html

(9) Перечислите отличия конструктора от метода.  
**Ответ.** Конструкторы предназначены для инициализации нового экземпляр класса, используют имя класса и выглядят
как методы без возвращаемого типа. Вызываются один раз при инициализации. Методы могут вызываться в любой момент сколько
угодно раз, и при их объявлении указывается возвращаемы тип данных (в том числе и ``void``).
Класс содержит конструкторы, которые вызываются для создания объектов из схемы класса. Объявления конструктора выглядят
как объявления методов, за исключением того, что они используют имя класса и не имеют возвращаемого типа.
Конструкторы не являются членами класса. Они никогда не передаются по наследству и поэтому не подлежат скрытию или отмене.
Доступ к конструкторам регулируется модификаторами доступа.  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/javaOO/summaryclasses.html  
https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8


(10) Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?  
**Ответ.** Можно вызвать один конструктор из другого в том же классе, или в надклассе, со следующими ограничениями:
Вызываемый конструктор должен быть в первой строке кода в вызывающем конструкторе.
Вложенный конструктор не может иметь никакой явной или неявной ссылки на ``this``. Таким образом, нету возможности попасть во внутренний класс.
В методе экземпляра или конструкторе this находится ссылка на текущий объект - объект, метод или конструктор которого
вызывается. Вы можете ссылаться на любой член текущего объекта из метода экземпляра или конструктора, используя ``this``  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

(11) Как и в каком месте можно вызвать конструктор суперкласса?  
**Ответ.**  Компилятор автоматически предоставляет конструктор по умолчанию без аргументов для любого класса без конструкторов.
Этот конструктор по умолчанию будет вызывать конструктор суперкласса без аргументов.
Для вызова конструктора суперкласса служит следующая общая форма ключевого слова ``super``:
super (список_параметров);
где список_параметров обозначает параметры, необходимые для нормальной работы конструктора суперкласса. Вызов конструктора ``super()``
должен быть первым оператором в теле конструктора подкласса. Вызвать его можно в теле конструктора подкласса.  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html

(12) Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?  
**Ответ.** Если конструктор не вызывает явно конструктор суперкласса, компилятор Java автоматически вставляет вызов
в конструктор суперкласса без аргументов. Если суперкласс не имеет конструктора без аргументов, вы получите ошибку
компиляции. ``Object`` имеет такой конструктор, так что если Object это единственный суперкласс,
нет никаких проблем.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/super.html

(13) Можно ли одновременно использовать конструкции ``this()`` и ``super()`` в одном и том же конструкторе?
Обоснуйте ответ.  
**Ответ.** Нет. this() вызывает конструктор данного класса, ``super()`` - конструктор класса-родителя. Обе инструкции должны
находиться на первой строке конструктора, что физически невозможно
**Источник.**  https://docs.oracle.com/javase/tutorial/java/IandI/super.html


(14) Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?  
**Ответ.** Класс может быть спроектирован так, чтобы код вне объявления класса не создавал экземпляров класса,
объявляя по крайней мере один конструктор, предотвращая создание неявного конструктора и объявляя все конструкторы как private.  
**Источник.**  https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.8.10

(15) Какие модификаторы может иметь конструктор?  
**Ответ.** Конструктор может объявляться только со спецификаторами видимости:
``public, private, protected`` или по умолчанию.  
**Источник.** И. Блинов Java from Epam стр. 70

(16) Конструктор принадлежит классу или экземпляру класса?  
**Ответ.** Конструктор принадлежит классу, но вызывается в контексте экземпляра
**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.3


(17) Можно ли наследовать конструктор?
Если да, то приведите примеры.  
**Ответ.** Подкласс наследует все члены (поля, методы и вложенные классы) от своего суперкласса. Конструкторы не являются членами,
поэтому они не наследуются подклассами, но конструктор суперкласса может быть вызван из подкласса  
**Источник.**  https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html

(18) Какой тип возвращаемого конструктором значения?  
**Ответ.** Конструктор не возвращает значение. Если к конструктору добавить возвращаемое значение, то он перестанет быть конструктором,
а превратится в метод данного класса. Компилятор при этом выдаст предупреждение о том, что в классе присутствуют методы с таким же именем,
как и класс, что является грубым нарушением соглашения о написании кода.  
**Источник.**  И. Блинов Java from Epam стр. 69 - 70


(19) Дан класс.
 ```java 
    class Null {  
        //фрагмент 1  
        Null Null() {  
            return null;  
        }  
        //фрагмент 2  
        Null() {  
            return null;  
        }  
    } 
 ``` 
(20) В каком фрагменте ошибка компиляции?
Удалите этот фрагмент полностью.
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.  
**Ответ.** Второй фрагмент является конструктором. Он ничего не должен возвращать, поэтому он неверен. Первый фрагмент верен,
но согласно соглашению, называть методы так же, как и класс неверно, так именуются конструкторы. Этот фрагмент вернет ``null``
 ```java
public static void main(String[] args) {
   Null object = new Null();
   object = object.Null();
   System.out.println(object); // null
}
 ``` 

(21) Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?  
**Ответ.** Конструктор не имеет возвращаемого значения. Если при определении конструктора указан тип возвращаемого значения (фрагмент 1) , то он считается методом
Пример:
 ```java 
    class Null {  
        //фрагмент 1  
        Null Null() {  
            return null;  
        }  
    } 
     
    public class Runner {
	    public static void main(String[] args) {
            Null exampleNull  = new Null();
            System.out.print(exampleNull.Null());
	    }

    }
 ``` 
Результат работы программы:
`null`


Дан класс.
 ```java 
    class Name {  
        String name;  
        Name() {
            name = makeRandomName();
        }
        Name(String name) {  
            super();  
            this.name = name;  
        }  
        String makeRandomName() {  
            int k = (int) (Math.random() * 3);  
            String name = new String[] {"Alpha", "Beta", "Gamma"}[k];  
            return name;  
        }  
        public String toString() {  
            return name;  
        }  
        public static void main(String[] args) {  
            System.out.println(new Name());  
        }  
    }
 ```  
(22) Объясните причину ошибки компиляции.
Предложите минимум 2 способа исправления ошибки, использовать метод ``makeRandomName()`` обязательно.  
**Ответ.** Чтобы сработал данный код, метод makeRandomName() должен быть статичным, т.к. на этапе работы кода из конструктора объект еще не создан,
и обратиться к данному методу нельзя. 1 способ  - установить для метода модификатор ``static``.
2 способ устранения — провести прямую инициализацию name в непараметризованном конструкторе:

    name = makeRandomName();

(23) Дан класс.
 ```java 
    class Int {  
        int i; 
        void inc(Int param) {  
            //param = new Int();  
            param.i++;  
        }  
        public static void main(String[] args) {  
            Int obj = new Int();  
            obj.inc(obj);  
            System.out.println(obj.i);  
        }  
    }  
 ```
(24) Изменится ли результат, если убрать комментарий?
Объясните, почему?  
**Ответ.** Если убрать комментарий, то в этой строке кода создастся новый локальный объект ``Int()``,
значение которого будет увеличено на +1, при этом передающийся в метод аргумент останется неизменным, т.к. param
примет ссылку на новый объект, и будет работать уже с ним, а с переданным аргументом не будет производиться никаких операций

(25) В чем смысл конструкции ``this``?
Перечислите случаи, когда используется конструкция ``this``.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?  
**Ответ.** Каждый экземпляр класса (объект) имеет неявную ссылку this на себя, которая передается также неявно и
нестатическим методам класса. После этого каждый метод «знает», какой объект его вызвал. Вместо обращения к атрибуту
accountId в методах можно писать this.accountId, хотя и не обязательно, так как записи accountId, this.accountId и
Account.this. accountId равносильны. Но если в методе объявлена локальная переменная или параметр метода с таким же
именем, как и поле класса, то для обращения к полю класса использование ``this`` обязательно. Без использования указателя
обращение всегда будет производиться к локальной переменной, так как просто не существует другого способа ее идентификации.
Наиболее частая причина использования ключевого слова ``this`` заключается в том, что поле затенено параметром метода или конструктора.
Изнутри конструктора вы также можете использовать ключевое слово this для вызова другого конструктора в том же классе.
Это называется явным вызовом конструктора .
Например, класс Point был написан так:
 ```java 
    public class Point {
        public int x = 0;
        public int y = 0;

        //constructor
        public Point(int a, int b) {
            x = a;
            y = b;
        }
    }
 ```    
но это можно было бы написать так:
 ```java 
    public class Point {
        public int x = 0;
        public int y = 0;
    
        //constructor
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
 ```
**Источник.**  И. Блинов Java from Epam стр. 71  
https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

(26) Можно ли присвоить null ссылочной переменной this?  
**Ответ.** Нет, нельзя. В Java левая часть оператора присваивания должен быть переменной. ``this`` — это специальное ключевое слово,
которое всегда дает текущий экземпляр класса. Это не любая переменная. Точно также, ``null`` нельзя присвоить переменной, используя ключевое слово ``super`` или любое другое подобное.  
**Источник.** https://javarush.ru/groups/posts/780-java-core-voprosih-k-sobesedovaniju-ch-3

(27) Перечислите случаи, когда используется статический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** Блок статической инициализации - это обычный блок кода, заключенный в фигурные скобки { },
и которому предшествует static ключевое слово.
Вот пример:
 ```java 
    static {  
        // любой код, необходимый для инициализации, идет сюда  
    } 
 ```
Класс может иметь любое количество статических блоков инициализации, и они могут появляться в любом месте тела класса.
Система времени выполнения гарантирует, что статические блоки инициализации вызываются в том порядке, в котором они появляются в исходном коде.
Есть альтернатива статическим блокам - вы можете написать приватный статический метод.Методы класса не могут напрямую
обращаться к переменным экземпляра или методам экземпляра - они должны использовать
ссылку на объект. Кроме того, методы класса не могут использовать ключевое слово this, поскольку нет экземпляра,
на который можно было бы ссылаться this.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html

(28) Перечислите случаи, когда используется логический блок?
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** При описании класса могут быть использованы логические блоки. Логическим блоком называется код, заключенный в
фигурные скобки и не принадлежащий ни одному методу текущего класса, например:
 ```java   
    { /* code */ }  
    static { /* code */ }  
```
Логические блоки чаще всего используются в качестве инициализаторов полей, но могут содержать вызовы методов и обращения к полям текущего класса.
При создании объекта класса они вызываются последовательно, в порядке размещения, вместе с инициализацией полей как простая
последовательность операторов, и только после выполнения последнего блока будет вызван конструктор класса. Операции с полями
класса внутри логического блока до явного объявления этого поля возможны только при использовании ссылки ``this``, представляющей собой ссылку на текущий объект
На практике статические логические блоки могут применяться для проверки и инициализации базовых параметров, необходимых для функционирования приложения или класса.
Нестатичексие логические блоки могут применяться для проверки и инициализации параметров конкретного объекта и для сокращения количества кода,
если одинаковый код присутствует в каждом конструкторе.  
**Источник.** И. Блинов Java from Epam стр. 85

(29) Что входит в сигнатуру метода?  
**Ответ.** В более общем смысле, объявления методов состоят из шести компонентов в следующем порядке:
Модификаторы доступа.
Тип возврата - тип данных значения, возвращаемого методом, или ``void`` если метод не возвращает значение.
Имя метода - правила для имен полей применяются также к именам методов, но соглашение немного отличается.
Список параметров в скобках-разделенный запятыми список входных параметров, которым предшествуют их типы данных, заключенные в скобки,().
Если параметров нет, необходимо использовать пустые скобки.
Список исключений
Тело метода, заключенное в фигурные скобки - это код метода, включая объявление локальных переменных.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html

(30) Что значит ключевое слово native?  
**Ответ.** Приложение на языке Java может вызывать методы, написанные на языке С++. Такие методы объявляются с ключевым словом ``native``,
которое сообщает компилятору, что метод реализован в другом месте.  
**Источник.** И. Блинов Java from Epam стр. 84

(31) Дан код.
 ```java
 public class BusinessTrip {  
        …  
        public String bynToStr(int value) {  
            return (value / 100) + "." + (value / 10 % 10) + (value % 10);  
        }  
    } 
  ```   

(32) Есть ли в нем семантическая ошибка?
Если да, то обоснуйте.  
**Ответ.** Если метод предполагает использование только внутри данного класса, то он должен быть ``private static``,
т.к. по его логике он принимает значение вне зависимоти от данных экземпляра класса.
Если метод может быть использован вне данного класса, то его стоит определить в отдельном утилитном классе и так же сделать статическим.

(33) Дан код.

```java
public class Utility {  
    private Utility() {  
        }  
        public String bynToStr(int value) {  
            return (value / 100) + "." + (value / 10 % 10) + (value % 10);  
        }  
    }
```
(34) Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты.  
**Ответ.**
сделав метод статичным мы избавимся от проблемы, однако, стоит отметить другое: для вызова bynToStr()
экземпляр класса не нужен, а нестатический метод в утилитном классе — это антипаттерн.

(35) К каким данным можно обратиться в статическом методе?  
**Ответ.** Статические поля и методы не могут обращаться к нестатическим полям и методам напрямую, так как они не «знают»,
к какому объекту относятся, да и сам экземпляр класса может быть не создан.  
Методы класса могут напрямую обращаться к переменным класса и методам класса.
Методы класса не могут напрямую обращаться к переменным экземпляра или методам экземпляра - они должны использовать
ссылку на объект. Кроме того, методы класса не могут использовать ключевое слово ``this``, поскольку нет экземпляра,
на который можно было бы ссылаться ``this``.
**Источник.** И. Блинов Java from Epam стр. 81  
https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html

(36) Почему нельзя объявить статическое поле внутри метода?  
**Ответ.** Внутри метода объявляются только локальные переменные метода, доступные только внутри метода  
**Источник.** https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html

(37) Перечислите, какой код в классе можно выполнить до создания объекта.  
**Ответ.**
1. Статический блок инициализации.
2. Логический блок инициализации.
3. Статические члены класса.
   **Источник.** И. Блинов Java from Epam стр. 81  
   https://docs.oracle.com/javase/specs/jls/se7/html/jls-12.html#jls-12.4


(38) В чем различие между объектом и экземпляром класса?  
**Ответ.** Java объект - чуть более широкое понятие чем экземпляр класса, включает в себя такие понятия,
как “экземпляр класса” и “массив”.
 ```java
    public class Cat  // объявление класса Cat  
    Cat cat; // объявление переменной, ссылающейся на объект (экземпляр) класса Cat  
    cat = new Cat  // создание нового объекта (экземпляра) класса Cat 
``` 

**Источник.** https://coderoad.ru/2885385/В-чем-разница-между-экземпляром-и-объектом  
https://docs.oracle.com/javase/specs/jls/se9/html/jls-4.html#jls-4.3.1


(39) Назовите три этапа создания экземпляра класса.  
**Ответ.** Объявление : представляет собой все объявления переменных, которые связывают имя переменной с типом объекта.
Создание экземпляра : ключевое слово new - это оператор Java, который создает объект.
Инициализация : за оператором new следует вызов конструктора, который инициализирует новый объект.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html

(40) Охарактеризуйте отношение композиции между классами? Как оно реализуется?  
**Ответ.** Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта,
но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины,
но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже.
Такие описания всегда несколько условны, но тем не менее.  
**Источник.** https://java-course.ru/begin/relations/

(41) Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами.  
**Ответ.** В данном случае необходимо в качестве возвращаемого значения использовать массив. Например:
 ```java   
     public int[] createArray(int size) {
        int[] myArray = new int[size]; 
        for(int i=0; i<size; i++) {  
            myArray[i] = i;  
        }  
        return myArray;  
    }  
```

Также допускается передача параметров с помощью объекта класса, хранящего два значения одного примитивного типа.

(42) Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.  
**Ответ.** Создать класс, представляющий результат, который необходимо вернуть, и вернуть экземпляр этого класса.
Дать классу значимое имя. Преимущества этого подхода-безопасность типов, и это сделает программу намного проще для понимания.
Пример:
 ```java
 final class MyResult {
    private final int first;
    private final String second;

    public MyResult(int first, String second) {
        this.first = first;
        this.second = second;
    }

    public int getFirst() {
        return first;
    }

    public String getSecond() {
        return second;
    }
    }

    // ...

    public static MyResult something() {
        int number1 = 1;
        String number2 = “2”;

        return new MyResult(number1, number2);
    }

    public static void main(String[] args) {
        MyResult result = something();
        System.out.println(result.getFirst() + result.getSecond());
    }
```

(43) Что такое иммутабельный объект?
Опишите 2 способа создания иммутабельных объектов.
Подсказка. Способ 1 - класс материала в classes2.
Какой альтернативный?
Подсказка - ключевое слово final для полей не использовать.
Создайте иммутабельный класс для вещества по альтернативному способу.
**Ответ.** Объект считается неизменным, если его состояние не может измениться после создания.
Максимальное использование неизменяемых объектов широко признано разумной стратегией создания простого и надежного кода.
Неизменяемые объекты особенно полезны в параллельных приложениях. Поскольку они не могут изменить состояние,
они не могут быть повреждены вмешательством потоков или наблюдаться в несогласованном состоянии.  
Следующие правила определяют простую стратегию создания неизменяемых объектов.
Не предоставляйте методы «установки» - методы, которые изменяют поля или объекты, на которые ссылаются поля.
Сделайте все поля ``final``.
Альтернативный способ – не создавать методов, способных изменять внутреннее состояние объекта.
**Источник.** https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html  
https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html

(44) Пример иммутабельного класса для вещества по альтернативному способу:
```java
    public class Material {
        private  String name;
        private  double density;
        Material();
        Material(String name, double density){
            this.name = name;
            this.density = density;
        }
        //getters
        public String getName(){
            return name;
        }
        public double getDensity(){
            return density;
        }
    }
 ```   


(45) Даны 2 класса.
```java
    final class Material {
        private final String name;
        private final double density;
        ...
    }
    class Runner {
        private static void printMaterial(final Material material) {
            System.out.println(material);
        }
        public static void main(String[] args) {
            Material steel = new Material("steel",7850);
            printMaterial(steel);
        }
    }
```
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)?  
**Ответ.** Новый объект не создается, имеется доступ к объекту  new Material("steel",7850). Модификатор final
запрещает изменение аргумента, однако, с помощью методов класса его можно изменить. В данном примере изменить данные объекта
нельзя, т.к. поля объявлены ``final``. Если поля будут без данного модификатора, их можно изменить с помощью методов класса.
Какой пример можно использовать для обоснования ответа?
Пример:
```java
    final class Material {
        private  String name;
        private  double density;
        public void setName(String Name){
            this.name = name;
        }
    ...
    }
    class Runner {
    private static void printMaterial(final Material material) {
        System.out.println(material);
        material.setName("Steel");
        System.out.println(material);
    }
    public static void main(String[] args) {
        Material steel = new Material("steel",7850);
        printMaterial(steel);
    }
    }
```

(46) Класс для комплексного числа содержит два поля:
```java
    class Complex {
        private double re;
        private double im;
        …
    }
```
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
**Ответ.**
```java
    class Complex {
        private double re;
        private double im;
        Complex ();
        Complex (double re, double im){
            this.re = re;
            this.im = im;
        }
        public Complex plus(Complex complex){
            double re = complex.re + this.re;
            double im = complex.im + this.im;
            return new Complex(re, im);
        }
        public Complex add(Complex complex){
                re += complex.re;
                im += complex.im;
            return this;
        }
    }

    public class Runner{
    public static void main(String[] args){
        Complex complex = new Complex(12.1, 15,2);
        Complex complexTwo  = new Complex(11.1, 12,2);
        complex.add(complexTwo);
        Complex complexThree = complex.plus(complexTwo);
    }
    }
 ```
Реализуйте эти же методы при условии, что класс Complex является иммутабельным.

```java
    class Complex {
        private final double re;
        private final  im;
        Complex ();
        Complex (double re, double im){
            this.re = re;
            this.im = im;
        }
        public Complex plus(Complex complex){
            double re = complex.re + this.re;
            double im = complex.im + this.im;
            return new Complex(re, im);
        }
    }

    public class Runner{
    public static void main(String[] args){
        Complex complex = new Complex(12.1, 15,2);
        Complex complexTwo  = new Complex(11.1, 12,2);
        Complex complexThree = complex.plus(complexTwo);
    }
    }
 ```
В данной реализации метод add не может быть реализован, т.к. класс является иммутабельным

(47) Для чего предназначен метод ``toString()``?
В каких случаях он вызывается?  
``toString()`` метод в Java используется для предоставления ясной и достаточной информации об объекта ``Object`` в удобном для человека виде. Правильное переопределение метода ``toString()`` может помочь в ведении журнала работы и в отладке Java программы предоставляя ценную и важную информацию. Поскольку ``toString()`` определен в ``java.lang.Object`` класса и его реализация по умолчанию не предоставляет много информации, всегда лучшей практикой является переопределение данного метода в классе-потомке.
https://javarush.ru/groups/posts/695-10-podskazok-po-pereopredeleniju-metoda-tostring-v-java-chastjh-1
Как реализован метод toString() в классе Object?  
**Ответ.**
```java
    public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
```  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html

(48) Для чего предназначен метод equals()?
В каких случаях он вызывается?  
**Ответ.** Метод ``equals()`` сравнивает два объекта для равенства и возвращает  true если они равны. Метод ``equals()``,
предоставляемый в ``Object`` классе использует оператор идентичности (``==``) , чтобы определить , являются ли два объекта равны.
Для примитивных типов данных это дает правильный результат. Однако для объектов это не так. Предоставляемый ``equals()``
метод ``Object`` проверяет, равны ли ссылки на объекты  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html

(49) Как реализован метод ``equals()`` в классе ``Object``?  
**Ответ.**
```java
    public boolean equals(Object obj) {
        return (this == obj);
    }
```
(50) В чем различие между методом ``equals()`` и операции ``==``?
В каких случаях применение метода ``equals()`` и операции ``==`` эквивалентно?
**Ответ.** Мы можем использовать операторы ``==`` для сравнения ссылочного сравнения (сравнения адресов) и ``equals()`` для сравнения содержимого.
Простыми словами ``==`` проверяет, указывают ли оба объекта на одну и ту же ячейку памяти, тогда как ``equals()`` оценивает сравнение значений в объектах.
Если класс не переопределяет метод equals, то по умолчанию он использует метод ``equals`` (``Object o``) ближайшего родительского класса, который переопределил этот метод.  
Для примитивных типов это эквивалентные операции.
Отличия ``equals()`` от операции ``==`` в классе ``Object`` нет.
Однако, нужно не забывать, что, если объект ни на что не ссылается(``null``), то вызов метода ``equals`` этого объекта приведет
к ``NullPointerException``. Также нужно помнить, что при сравнении объектов оба они могут быть ``null`` и операция obj1 == obj2
в данном случае будет ``true``, а вызов equals приведет к исключению ``NullPointerException``.
Как мы видим, при помощи операции ``==`` сравниваются ссылки на объекты. Но мы можем переопределять метод ``equals``, тем самым
задавая логику сравнения двух объектов.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html  
http://www.quizful.net/interview/java/equals-equality-difference


(51) Eclipse в стандартной конфигурации генерирует начало метода ``equals()`` следующим образом:
 ```java
 public boolean equals(Object obj){
        if(this==obj)
            return true;
        if(obj==null)
         return false;
}
```
С чем связаны данные проверки, которые кажутся лишними?  
**Ответ.** Метод ``equals`` класса ``Object`` реализует наиболее разборчивых возможное отношение эквивалентности на объектах;
то есть для любых ненулевых ссылочных значений x и y этот метод возвращает ``true`` тогда и только тогда, когда x и y ссылается
на один и тот же объект ( ``x == y`` имеет значение ``true``).  
`if (obj == null) `— для любой ненулевой ссылки на значение x, выражение `x.equals(null)` должно возвращать `false` —
выполнение эанного условия помогает избежать `NullPointerException`.
При переопределении метода `equals()` должны выполняться соглашения, предусмотренные спецификацией языка Java,
т.е. рефлексивность, симметричность, транзитивность, непротиворечивость, сравнение с литералом `null`.

**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)


(52) Что такое garbage collection?  
**Ответ.** Garbage Collector (GB) часть JVM, который призван очищать память, выделенную приложению. Он должен: найти мусор (неиспользуемые объекты), удалить мусор.  
**Источник.**  https://ziginsider.github.io/Garbage_Collector_Java/

(53) Перечислите случаи, когда JVM отдает управление на garbage collector.  
**Ответ.**  Среда выполнения Java удаляет объекты, когда определяет, что они больше не используются. Этот процесс называется сборкой мусора .
Объект имеет право на сборку мусора, если на него больше нет ссылок. Ссылки, которые хранятся в переменной, обычно удаляются,
когда переменная выходит за пределы области видимости. Или вы можете явно удалить ссылку на объект, установив для переменной специальное значение ``null ``.
Помните, что программа может иметь несколько ссылок на один и тот же объект; все ссылки на объект должны быть отброшены, прежде чем объект получит право на сборку мусора.
В среде выполнения Java есть сборщик мусора, который периодически освобождает память, используемую объектами,
на которые больше нет ссылок. Сборщик мусора выполняет свою работу автоматически, когда определяет, что время пришло.
jvm может передать управление сборщику мусора на свое усмотрение, например, в случае переполнения стека памяти  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/usingobject.html

(54) Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?  
**Ответ.** Лучший вариант-вызвать ``System.gc()`` (либо ``Runtime.getRuntime().gc()``), который просто намекает сборщику мусора, что вы хотите, чтобы он сделал сборку.

(55) Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти?
Обоснуйте ответ.  
**Ответ.** Нет, всегда возможно, что вы попытаетесь выделить больше памяти, чем доступно.
Автоматическая сборка мусора означает только то, что мусор (т. е. неиспользуемая память) автоматически собирается
(т. е. утилизируется для дальнейшего использования). Если вы сохраняете ссылки на него, это не мусор и не собирается.  
**Источник.** https://coderoad.ru/2097461/Гарантирует-ли-сборка-мусора-что-программа-не-будет-работать-без-памяти#2097485

(56) Для чего предназначен метод ``finalize()``?
Какой недостаток у метода?  
**Ответ.** Некоторым аналогом деструктора являлся метод ``finalize()``,
в тело которого помещается код по освобождению занятых объектом ресурсов,
но в настоящее время данный метод помечен как deprecated и не рекомендован
к использованию. Тем не менее виртуальная машина станет вызывать его каждый раз, когда «сборщик мусора» будет уничтожать объект класса, которому не
соответствует ни одна ссылка.  
**Источник.** И. Блинов Java from Epam стр. 70

(57) Для чего предназначены оболочечные классы?
Как они называются на инглише?  
**Ответ.** Однако есть причины использовать объекты вместо примитивов, и платформа Java предоставляет классы- оболочки
для каждого из примитивных типов данных. Эти классы «оборачивают» примитив в объект. Часто упаковка выполняется компилятором-
если вы используете примитив там, где ожидается объект, компилятор помещает примитив в свой класс-оболочку для вас. Точно так же,
если вы используете числовой объект, когда ожидается примитив, компилятор распаковывает объект за вас.   
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/numberclasses.html


(58) В чем преимущество примитивных типов перед соответствующими оболочечными классами?  
**Ответ.** Между примитивными и упакованными примитивными типами есть три основных различия.
Во-первых, у примитивных типов есть только значения, в то время как у упакованных примитивных типов имеется еще и идентичность
(``identities``), отличная от их значений. Иными словами, два экземпляра упакованных примитивных типов могут иметь одинаковые значения, но разные
идентичности. Во-вторых, примитивные типы имеют только полнофункциональные значения, в то время как каждый упакованный примитивный
тип имеет одно нефункциональное значение —`` null`` — в дополнение ко всем функциональным значениям соответствующего примитивного типа. И наконец,
примитивные типы более эффективны с точки зрения потребления памяти и времени работы, чем упакованные примитивные типы. Все эти различия могут
привести к реальным проблемам при неосторожном использовании упакованных примитивных типов
**Источник.**  Дж. Блох “Java эффективное программирование”  стр. 334


(59) Что такое ``autoboxing`` и ``unboxing``?  
**Ответ.** В Java определен процесс автоматической инкапсуляции данных базовых
типов в соответствующие объекты оболочки и обратно (автоупаковка/автораспаковка).
При этом нет необходимости в явном создании соответствующего объекта с использованием методов.
Автораспаковка — процесс извлечения из объекта-оболочки значения базового типа. Вызовы методов ``intValue()``, ``doubleValue()``
и им подобных для преобразования объектов в значения базовых типов становятся излишними.  
**Источник.** И. Блинов Java from Epam стр. 46-47

(60) Дан код:
```java
    Integer a = 3, b =7;
    Long c = a + b;
```
Перечислите все операции, где задействованы autoboxing и unboxing.  
**Ответ.**
Правильно будет Long c = (long) (a + b);
в данном случае, сперва происходит сложение примитивов из оболочек (a + b), далее полученный примитив упаковывается в оболочку Long c
a = 3, b =7, a + b – autoboxing
c = - unboxing

(61) Дан корректный раннер-класс.
Будет ли ошибка компиляции, если удалить модификатор ``static`` из сигнатуры метода ``main()``?
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?  
**Ответ.** : С точки зрения синтаксиса программы ошибки не будет, т.е. компилятор не станет оповещать разработчика о
каких-либо проблемах (ошибки компиляции не будет!), однако в результате выполнения будет получена такая ошибка:  
`Error: Main method is not static in class Runner, please define
the main method as:
public static void main(String[] args)`

(62) Дан класс.
```java
    class Runner {
    public static void main(String[] args) {
    System.out.println("Hello, world!");
    }
    }
```
Запрещается изменять синий код, т.е. метод ``main()``.
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:

    I am java.
    Hello, world!

**Ответ.**
```java

class Runner {
   static {
      System.out.println("I am java.");
   }
   public static void main(String[] args) {
      System.out.println("Hello, world!");
   }
}
```