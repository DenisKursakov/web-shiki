**Theory collections**

**Questions:**

1: Дайте неформальное определение контейнера.  
**Ответ:** Коллекция, иногда называемая контейнером, — это просто объект, объединяющий несколько элементов в единое целое. 
Коллекции используются для хранения, извлечения, обработки и передачи агрегированных данных. 
Как правило, они представляют собой элементы данных, образующие естественную группу, 
например покерную комбинацию (набор карт), почтовую папку (набор писем) или телефонный 
справочник (сопоставление имен и телефонных номеров).  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  

2: Дайте определение коллекции в `java`.  
**Ответ:** Коллекции — это хранилища или контейнеры, поддерживающие различные
способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих три основные операции:
• добавление нового элемента в коллекцию;
• удаление элемента из коллекции; • изменение элемента в коллекции.
В качестве других операций могут быть реализованы следующие: заменить,
просмотреть элементы, подсчитать их количество и др.  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 253  

3: Какой имеется в `java` контейнер, отличный от коллекций?  
Дайте ему определение.  
**Ответ:** Массив — это структура данных, в которой хранятся элементы одного типа. 
Его можно представить, как набор пронумерованных ячеек, в каждую из которых можно поместить 
какие-то данные (один элемент данных в одну ячейку). 
Доступ к конкретной ячейке осуществляется через её номер. 
Номер элемента в массиве также называют индексом.  
**Источник:** https://javarush.ru/groups/posts/massivy-java  

4: Дайте определение `Collections framework`?  
**Ответ:** `Java Collection Framework` —  это унифицированная архитектура для представления коллекций и управления ими.     
**Источник:** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  

5: Какие разделы содержит `Collections framework`?
Определите их, и для чего они предназначены?  
**Ответ:** 
а) Интерфейсы: это абстрактные типы данных, представляющие коллекции. 
Интерфейсы позволяют управлять коллекциями независимо от деталей их представления. 
В объектно-ориентированных языках интерфейсы обычно образуют иерархию.  
б) Реализации: это конкретные реализации интерфейсов коллекций. 
По сути, это повторно используемые структуры данных.  
в) Алгоритмы: это методы, которые выполняют полезные вычисления, такие как поиск и сортировка, 
над объектами, которые реализуют интерфейсы коллекций. Алгоритмы называются полиморфными : 
то есть один и тот же метод может использоваться во многих различных реализациях соответствующего 
интерфейса коллекции. По сути, алгоритмы — это повторно используемые функции.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  

6: В чем преимущества использования `Collections Framework` ?  
**Ответ:** Java Collections Framework предоставляет следующие преимущества:  
а) Сокращает усилия по программированию: Предоставляя полезные структуры данных и алгоритмы, 
`Collections Framework` позволяет вам сконцентрироваться на важных частях вашей программы, 
а не на низкоуровневой «сантехнике», необходимой для ее работы. Упрощая взаимодействие между 
несвязанными `API`, `Java Collections Framework` освобождает вас от написания объектов адаптера или 
кода преобразования для подключения `API`.  
б) Увеличивает скорость и качество программы: структура коллекций обеспечивает высокопроизводительные и 
высококачественные реализации полезных структур данных и алгоритмов. Различные реализации каждого 
интерфейса взаимозаменяемы, поэтому программы можно легко настраивать, переключая реализации коллекций. 
Поскольку вы освобождаетесь от рутинной работы по написанию собственных структур данных, у вас 
появляется больше времени для улучшения качества и производительности программ.  
в) Обеспечивает взаимодействие между несвязанными `API`: интерфейсы коллекций — это язык, с помощью 
которого `API` передают коллекции туда и обратно. Если мой `API`-интерфейс сетевого администрирования 
предоставляет набор имен узлов, а ваш инструментарий `GUI` ожидает набор заголовков столбцов, наши 
`API`-интерфейсы будут беспрепятственно взаимодействовать, даже если они были написаны независимо друг от друга.  
г) Сокращает усилия по изучению и использованию новых `API`: многие `API` естественным образом 
принимают коллекции на входе и предоставляют их на выходе. Раньше у каждого такого `API` был небольшой 
суб-`API`, предназначенный для управления его коллекциями. Между этими специальными `API`-интерфейсами 
коллекций было мало согласованности, поэтому вам приходилось изучать каждый из них с нуля, 
и при их использовании было легко сделать ошибки. С появлением стандартных интерфейсов коллекций проблема ушла.  
д) Сокращает усилия по разработке новых `API`: это обратная сторона предыдущего преимущества. 
Дизайнерам и разработчикам не нужно изобретать велосипед каждый раз, когда они создают `API`, 
основанный на коллекциях; вместо этого они могут использовать стандартные интерфейсы коллекций.  
е) Способствует повторному использованию программного обеспечения: новые структуры данных, 
соответствующие стандартным интерфейсам коллекций, по своей природе допускают повторное использование. 
То же самое касается новых алгоритмов, работающих с объектами, реализующими эти интерфейсы.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  

7: Является ли антипаттерном следующее объявление ссылки на коллекцию?  
`Collection collection;`  
Если да, то как называется антипаттерн и исправьте объявление ссылки.  
**Ответ:** Данное объявление является антипаттерном - `raw type`. Правильное объявление будет выглядеть следующим образом:  
`Collection<...> collection`.  

8: К каким негативным последствиям может привести использование `raw types`? 
Приведите пример.  
**Ответ:** Когда вы объявляете `Collection` экземпляр, вы можете и должны указать тип объекта, 
содержащегося в коллекции. Указание типа позволяет компилятору проверить (во время компиляции), 
что тип объекта, который вы помещаете в коллекцию, является правильным, тем самым уменьшая количество 
ошибок во время выполнения.

```java 
public class UncheckCheckRun {
public static void main(String[ ] args) {
 ArrayList raw = new ArrayList() { // "сырая" коллекция – raw type
 { // логический блок анонимного класса
 add(new Order(231, 12.f));
 add(new Item(23154, 120.f, "Xerox"));
 add(new Order(217, 1.7f));
 }
 };
 // при извлечении требуется приведение типов
 Order or1 = (Order) raw.get(0);
 Item or2 = (Item) raw.get(1);
 Order or3 = (Order) raw.get(2);
 for (Object ob : raw) {
 System.out.println("raw " + ob);
 }
 ArrayList<Order> orders = new ArrayList<Order>() {
 {
 add(new Order(231, 12.f));
 add(new Order(389, 2.9f));
 add(new Order(217, 1.7f));
 // add(new Item(23154, 120.f, "Xerox"));
				// ошибка компиляции: список параметризован
 }
 };
 for (Order ob : orders) {
 System.out.println("Order: " + ob);
 } 
 } 
 }
```
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 256  
https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html  

9: Почему допускаются `raw types` с коллекциями?  
Необработанные типы (`raw types`) отображаются в устаревшем коде, потому что многие классы `API` 
(например, классы `Collections`) не были универсальными до `JDK 5.0`. 
При использовании необработанных типов вы, по сути, получаете поведение до дженериков.  
Есть всего три случая, когда использовать обобщенный тип без параметра правильно:  
• Целевая версия `Java < 5.0 `(2002 год и ранее – вряд ли это ваш случай);  
• В литерале класса. `List<String>.class` не сработает, нужно писать `List.class`;  
• В операторе `instanceof`. Вместо `instanceof Set<Integer>` должно быть `instanceof Set`.  
**Источник:** https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html  
https://itsobes.ru/JavaSobes/kogda-nuzhno-ispolzovat-raw-types/  

10: Какое главное назначение раздела Интерфейсы?  
Другими словами, если известен интерфейс коллекции, то что это дает
программисту?  
**Ответ:** Если известен интерфейс коллекции, то программист понимает множество методов, 
которые каждый класс, использующий интерфейс, должен реализовывать. Так же очевидна основной функционал созданной коллекци. 
На примере интерфейса `List` программисту очевидно что коллекция будет представлять собой список (не множество, не карту и т.д.) 
Соответственно классы для реализации - `ArrayList, LinkedList и др.`. 
**Источник:** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  

11: Какое главное назначение раздела Имплементации?  
Другими словами, если известна имплементация, то что это дает программисту?  
**Ответ:** Увеличивает скорость и качество программы: По сути, это повторно используемые структуры данных. Различные реализации каждого 
интерфейса взаимозаменяемы, поэтому программы можно легко настраивать, переключая реализации коллекций. 
Поскольку вы освобождаетесь от рутинной работы по написанию собственных структур данных, 
у вас появляется больше времени для улучшения качества и производительности программ.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/intro/index.html  

12: Приведите иерархию интерфейсов коллекций.  
**Ответ:** От интерфейса `Collection` - по иерархии идут интерфейсы - `List, Set, Queue, Deque` от 
интерфейса `Set` - `SortedSet`;
Отдельная иерархия не принадлежащая `Collection` иерархия интерфейса `Map` - `SortedMap`;
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/index.html  

13: Какие существуют способы прохода (traversing) по коллекции до версии `java 8` (т.е.
от версии 5 до версии 7 включительно)?
Приведите идиомы для следующей коллекции:
```java 
Collection<Entity> entities = …;
```  
Какой способ является более подходящим для прохода по коллекции до версии
`java 8`?   
**Ответ:**
`for-each` конструкция позволяет вам сжато перемещаться по коллекции или массиву с помощью `for` 
цикла — см . Оператор `for`. Следующий код использует `for-each` конструкцию для вывода каждого элемента 
коллекции в отдельной строке.  
`Iterator` — это объект, который позволяет вам перемещаться по коллекции и выборочно удалять 
элементы из коллекции, если это необходимо. Вы получаете `Iterator` коллекцию, вызывая ее `iterator` метод.
```java 
Collection<Enity> entities = ...;
for (Enity e : entities) {
System.out.println(e);
}
 for (Iterator<Entity> it = entities.iterator(); it.hasNext(); )
        if (!cond(it.next()))
            it.remove();
```  
В зависимости от условия поставленной задачи следует выбирать определенный способ прохода. Если по условию 
кроме вывода требуется проводить операции удаление текущего элемента следует использовать `Iterator`.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

14: Реализация какого интерфейса позволяет коллекциям использоваться в конструкции `for-each`?
Какой метод этого интерфейса обеспечивает данную возможность?  
**Ответ:** Интерфейс `Collection` расширяет интерфейс `Iterable`. Поэтому цикл "for each" можно 
использовать для любого набора данных из стандартной библиотеки.
Компилятор преобразует цикл `for each` в обычный цикл с итератором. Цикл `for each` работает с 
любым объектом, реализующим интерфейс `Iterable`, в котором объявлен единственный метод  
```java 
public interface Iterable <E>
{
    Iterator <E> iterator();
}
```
**Источник:** https://java-online.ru/java-collection.xhtml  

15: Что такое итератор?  
**Ответ:** Интерфейс `Iterator<E>` используется для построения объекта, который
обеспечивает доступ к элементам коллекции. К этому типу относится объект,
возвращаемый методом `iterator()`. Такой объект позволяет просматривать содержимое коллекции 
последовательно, элемент за элементом. Позиции итератора располагаются в коллекции между элементами.  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255  

16: Дана коллекция из `n` элементов.
Сколько в ней существует возможных позиций курсора итератора?  
**Ответ:** В коллекции, состоящей из `N` элементов, существует `N+1` позиций итератора.  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255  

17: Какие методы объявлены в интерфейсе `Iterator<E>`?  
Охарактеризуйте их.  
**Ответ:** 
Методы интерфейса `Iterator<E>`:  
```java 
boolean hasNext() — проверяет наличие следующего элемента, а в случае 
его отсутствия (завершения коллекции) возвращает false. Итератор при этом 
остается неизменным;
E next() — возвращает ссылку на объект, на который указывает итера-
тор, и передвигает текущий указатель на следующий, предоставляя доступ 
к следующему элементу. Если следующий элемент коллекции отсутствует, 
то метод next() генерирует исключение NoSuchElementException;
void remove() — удаляет объект, возвращенный последним вызовом метода 
next(). Если метод next() до вызова remove() не вызывался, то будет сгенериро-
вано исключение IllegalStateException.
```  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255  

18: В каких случаях следует явно использовать итератор вместо `for-each`?  
**Ответ:** Используйте `Iterator` вместо `for-each` конструкции, когда вам нужно:  
а) Удалить текущий элемент. Конструкция `for-each` скрывает итератор, поэтому вы не можете вызвать `remove`.
Поэтому эту `for-each` конструкцию нельзя использовать для фильтрации.  
б) Параллельно перебирать несколько коллекций.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html  

19: Пусть условие удаления элемента из коллекции `Collection<Entity> entities` задается
методом `isRemoved()` класса `Entity`.
Приведите идиому удаления элементов этой коллекции.  
**Ответ:** 
```java 
    for (Iterator<Entity> it = entities.iterator(); it.hasNext();) 
        if (!it.next().isRemoved()) 
            it.remove(); 
``` 


20: Какие группы методов (или операций) объявлены в интерфейсе `Collection`
(до `java 8`)?  
Какие методы входят в каждую группу?  
**Ответ:**
В интерфейсе `Collection<E>` определены методы, которые работают на всех
коллекциях:
```java 
boolean add(E obj) — добавляет obj к вызывающей коллекции и возвраща-
ет true, если объект добавлен, и false, если obj уже элемент коллекции;
boolean remove(Object obj) — удаляет obj из коллекции;
boolean addAll(Collection<? extends E> c) — добавляет все элементы кол-
лекции к вызывающей коллекции;
void clear() — удаляет все элементы из коллекции;
boolean contains(Object obj) — возвращает true, если вызывающая коллек-
ция содержит элемент obj;
boolean equals(Object obj) — возвращает true, если коллекции эквивалентны;
boolean isEmpty() — возвращает true, если коллекция пуста;
Iterator<E> iterator() — извлекает итератор;
int size() — возвращает количество элементов в коллекции;
Object[] toArray() — копирует элементы коллекции в массив объектов;
<T> T[] toArray(T a[]) — копирует элементы коллекции в массив объектов
определенного типа.
```  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255  

21: В чем разница методов `Object[] toArray(), <T> T[] toArray(T[] a)` интерфейса
`Collection`?  
**Ответ:** 
```java 
Object[] toArray() — копирует элементы коллекции в массив объектов;
<T> T[] toArray(T a[]) — копирует элементы коллекции в массив объектов
определенного типа.
``` 
Метод `<T> T[] toArray(T a[])` отличается тем, что копирует элементы определенного типа, в то время как 
метод `Object[] toArray()` копирует объекты типа `Object` то есть любого типа.  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 255

22: В описании методов интерфейсов коллекций в `JavaDoc` есть методы, помеченные
фразой “optional operation”.
`Modifier and Type Method and Description
boolean add(E e)
Ensures that this collection contains the specified element
(optional operation).
boolean addAll(Collection<? extends E> c)
Adds all of the elements in the specified collection to this
collection (optional operation).
void clear()
Removes all of the elements from this collection (optional
operation).`  
Как это понимать?  
**Ответ:** Необязательными методами в `JavaDoc` называются методы интерфейса которые не обязан реализовывать 
класс, реализующий интерфейс. Вместо этого вместо этого они могли бы, например, создать исключение. 
Эти методы могут, но не обязаны, выдавать `UnsupportedOperationException` если вызов не повлияет на коллекцию.  
**Источник:** https://stackoverflow.com/questions/8375653/what-does-optional-operation-mean-in-javadoc-of-for-example-setadde  

23: Какую математическую сущность моделирует интерфейс `Set`?  
**Ответ:** Интерфейс `Set` моделирует математическую абстракцию множества.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

24: Какое основное свойство всех имплементаций интерфейса `Set`, т.е. что их
объединяет независимо от имплементации?  
**Ответ:** Интерфейс `Set`имеет 3 имплементации, которые не могут содержать повторяющиеся элементы.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

25: Может ли множество содержать `null` элемент?  
**Ответ:** Множество инициализируется списком. Соответственно множество не может содержать `null` элемент.   
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 273  

26: Есть ли отношение следования (предыдущий, текущий, следующий элемент) в
множестве? 
Если нет, то есть ли у множества итератор?  
**Ответ:** Отношение следования в множестве нет, однако интерфейс `Set` имеет итератор.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

27: Как получить элемент множества по индексу?  
**Ответ:** Индекс в привычном понимании у элементов множества нет. 
Ключ (хэш-код) используется в качестве индекса хэш-таблицы для доступа
к объектам множества, что значительно ускоряет процессы поиска, добавления
и извлечения элемента.  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 273  

28: Как реализован метод `add()` во множестве?  
**Ответ:** Метод `add` добавляет указанный элемент в, `Set` если он еще не присутствует, и возвращает логическое 
значение, указывающее, был ли добавлен элемент.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

29: Какая группа методов увеличилась в интерфейсе `Set` по сравнению с
интерфейсом `Collection`? 
Какие методы добавились?  
**Ответ:** Интерфейс `Set` содержит только методы, унаследованные от `Collection`. 
Так же у `Set` есть перегруженные методы `containsAll, addAll, retainAll, removeAll`, 
которые принимают `Set`, как аргумент и соответствуют математическим операциям над множествами.  
**Источник:** https://metanit.com/java/tutorial/5.4.php  

30: Зависит ли множество, как структура данных, от имплементации?
Обоснуйте ответ.  
**Ответ:** Да, т.к. переменные и параметры множества должны соответствовать типу реализации. 
Обратите внимание, что код всегда ссылается на `Collection` тип интерфейса `Set`, 
а не на тип реализации. Это настоятельно рекомендуемая практика программирования, поскольку она 
дает вам возможность изменять реализации, просто изменяя конструктор. 
Если какая-либо из переменных, используемых для хранения коллекции, или параметры, 
используемые для ее передачи, объявлены как имеющие `Collection` тип реализации, 
а не тип его интерфейса, все такие переменные и параметры должны быть изменены, чтобы изменить его тип реализации.
Кроме того, нет никакой гарантии, что получившаяся программа будет работать. 
Если в программе используются какие-либо нестандартные операции, присутствующие в исходном 
типе реализации, но отсутствующие в новом, программа завершится ошибкой. Обращение к коллекциям 
только по их интерфейсу предотвращает использование каких-либо нестандартных операций.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

31: Какие методы должны быть переопределены в классе, которым параметризовано
множество, чтобы гарантировать правильную работу `HashSet` имплементации?  
**Ответ:**  `Set` также добавляет более строгое соглашение о поведении операций `equals` и `hashCode`, 
что позволяет `Set` осмысленно сравнивать экземпляры, даже если их типы реализации различаются. 
Два `Set` экземпляра равны, если они содержат одни и те же элементы.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

32: Какие соглашения установлены для переопределения метода `hashCode()`?  
**Ответ:**
Хэш — это некоторое число, генерируемое на основе объекта и описывающее его состояние в какой-то 
момент времени. Это число используется в Java преимущественно в хэш-таблицах, таких как `HashMap`. 
При этом хэш-функция получения числа на основе объекта должна быть реализована таким образом, чтобы 
обеспечить относительно равномерное распределение элементов по хэш-таблице. А также минимизировать 
вероятность появления коллизий, когда по разным ключам функция вернет одинаковое значение.  
Для реализации хэш-функции в спецификации языка определены следующие правила:  
а) Вызов метода `hashCode` один и более раз над одним и тем же объектом должен возвращать одно и 
то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
б) Вызов метода `hashCode` над двумя объектами должен всегда возвращать одно и то же число, если 
эти объекты равны (вызов метода `equals` для этих объектов возвращает `true`).
в) Вызов метода `hashCode` над двумя неравными между собой объектами должен возвращать 
разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его 
выполнение положительно повлияет на производительность работы хэш-таблиц.
**Источник:** https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam  

33: Почему недостаточно переопределить один только метод `hashCode()`?  
**Ответ:** 
Исходя из описанных выше контрактов следует, что переопределяя в своем коде метод `equals`, 
необходимо всегда переопределять и метод `hashCode`. Так как фактически два экземпляра класса 
отличаются, потому что находятся в разных областях памяти, сравнивать их приходится по некоторым 
логическим признакам. Соответственно, два логически эквивалентных объекта, должны возвращать 
одинаковое значение хэш-функции.  
**Источник:** https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam  

34: Являются ли приведенная реализация `hashCode()` допустимой (в смысле будут ли
правильно выполняться все операции над множеством)?  
```java 
@Override
public int hashCode() {
return 22;
}
```  
**Ответ:** Такая реализация допустима, однако такая реализация не предполагает достаточную уникальность для сравнения. 
Каждый объект класса будет иметь одинаковый хэш код, вне зависимости от значений полей класса. 
Так же данная реализация повлияет поиск и получение (удаление) элементов множества, т.к. эти операции проходят при помощи 
`hashCode` который в данном случае будет одинаковый у всех объектов.  

35: Являются ли приведенная реализация `hashCode()` допустимой (в смысле будут ли
правильно выполняться все операции над множеством `HashSet<Entity>`)? 
```java 
class Entity {
private int value;
public int getValue() {
return value;
}
public void setValue(int value) {
this.value = value;
}
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null || getClass() != obj.getClass()) return false;
Entity entity = (Entity) obj;
return value == entity.value;
}
@Override
public int hashCode() {
int result = 1;
result = result * 31 + value;
return result;
} 
}
```  
**Ответ:** Такая реализация не допустима. Т.к. предполагается что поле `value` может быть изменено с помощью сеттера, и так же поле 
`value` участвует в генерации `hashCode` можно сделать вывод что после изменения `value` будет изменен и 
`hashCode` элемента, соотвественно элемент попадет в другую "коризну". Таким образом может произойти "потеря элемента".  
**Источник:** https://habr.com/ru/post/162017/  

36: Какие методы должны быть переопределены в классе, которым параметризовано
множество, чтобы гарантировать правильную работу `TreeSet` имплементации?  
**Ответ:** Метод `Comparator <? super E> comparator()` возвращает объект 
`Comparator`, используемый для сортировки объектов множества или `null`,
если выполняется обычная сортировка. `TreeSet` экземпляр выполняет все сравнения элементов, 
используя свой `compareTo(или compare)` метод, поэтому два элемента, которые считаются 
равными этому метода с точки зрения множества равны.  
**Источник:** https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html  
И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 273

37: В чем заключается актуальность внешнего компаратора?  
**Ответ:** Преимущество использования `Comparator` (внешнего компаратора) заключается в том, что нет необходимости изменять 
исходный код, а нужно реализовать компаратор. Когда нужно сравнить настраиваемый объект, компаратор 
и объект могут быть переданы вместе для сравнения размера, а в `Comparator` Пользователи могут сами 
реализовать сложную и универсальную логику.  
**Источник:** https://russianblogs.com/article/3860744737/  

38: Дана следующая коллекция: 
`Collection<Entity> entities = …;`
Приведите идиому, позволяющую оставить только уникальные элементы в коллекции при условии правильной 
реализации класса `Entity`.  
**Ответ:** 
```java 
Collection<Entity> entities = …;  //1 В случае если коллекция уже инициализированна без попомщи Set интерфейса
Set<Entity> entitiesSet = new HashSet<>(entities);
Collection<Entity> entities = new HashSet<>(entities); //2 В случае если коллекция по условию еще не была инициализирована 
```

39: Какую математическую сущность моделирует интерфейс `List`?  
**Ответ:** `List` — упорядоченная `Collection` (иногда называемая последовательностью).  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  

40: Какое основное свойство всех имплементаций интерфейса `List`, т.е. что их
объединяет независимо от имплементации?  
**Ответ:** Обе имплементации интерфейса предполагают наличие упорядоченного "списка" к элементам которого можно обращаться 
по индексу. Для быстрой работы с методами "вставки, удаления, получения" элементов.  

41: Может ли имплементация интерфейса `List` содержать одинаковые элементы?  
Обоснуйте ответ. 
**Ответ:** Да. Списки могут содержать повторяющиеся элементы. Однако некоторые реализации интерфейса `List` 
имеют некоторые ограничения. К примеру не могут содержать элементы `null`.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  

42: Какие группы методов увеличились в интерфейсе `List` по сравнению с
интерфейсом `Collection`?  
Какие методы добавились?  
**Ответ:** 
```java 
void add(int index, E element)— вставляет element в позицию, указанную в index; 
E remove(int index)— удаляет объект из позиции index; 
E set(int index, E element)— заменяет объект в позиции index, возвращает 
при этом удаляемый элемент;
void addAll(int index, Collection<? extends E> c)— вставляет в вызывающий 
список все элементы коллекции с, начиная с позиции index; 
E get(int index)— возвращает элемент в виде объекта из позиции index;
int indexOf(Object ob)— возвращает индекс указанного объекта;
List<E> subList(int fromIndex, int toIndex) — извлекает часть коллекции 
в указанных границах.
```
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 256  

43: Влияют ли изменения внесенные в последовательность, возвращаемый методом
`subList()`, на исходную последовательность?  
**Ответ:** Да, при использовании операции `subList` необходимо проявлять некоторую осторожность. 
Семантика `List` возвращаемого `subList` становится неопределенной, если элементы добавляются 
или удаляются из резервной копии `List` любым способом, кроме как через возвращаемый `List`.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  

44: Дана следующая последовательность: 
`List<Entity> entities = …;`
Приведите идиому, позволяющую удалить все элементы с номерами из
полусегмента `[fromIndex; toIndex)`.  
**Ответ:** 
```java 
List<Entity> entities = …;
entities.subList(fromIndex, toIndex).clear();
```  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  

45: Дана следующая неупорядоченная последовательность и некоторый элемент для
сравнения:
`List<Entity> entities = …;
Entity cmpEntity = …;` 
Приведите идиому для выполнения метода `void doAction()` класса `Entity` со всеми
элементами последовательности `entities`, которые совпадают с элементом
`cmpEntity`.  
_Запрещается_ упорядочивать последовательность и явно проверять на равенство каждый элемент последовательности.  
**Ответ:** 
```java 
List<Entity> entities = …;
Entity cmpEntity = …;
int id = 0;
while(entities.indexOf >= 0) {
id = entities.indexOf(cmpEnity);
entities.get(id).doAction();
entities.remove(id);
}
```

46: Какую математическую сущность моделирует интерфейс `Queue`?  
**Ответ:** Queue— это коллекция для хранения элементов перед обработкой.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html  

47: Какое основное свойство всех имплементаций интерфейса `Queue`, т.е. что их
объединяет независимо от имплементации?  
**Ответ:** Каждая имплементация интерфейса Queue должна указывать свои свойства упорядочивания 
элементов в очереди, при этом элементы добавляются в один конец списка, а извлекаются из другого конца.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html  

48: Какие группы методов увеличились в интерфейсе `Queue` по сравнению с
интерфейсом `Collection`?
Какие методы добавились?  
**Ответ:**
Помимо основных `Collection` операций, очереди предоставляют дополнительные операции вставки, удаления и проверки. 
```java 
Методы интерфейса Queue:
boolean add(E o) вставляет элемент в очередь, но если же очередь полностью заполнена, то генерирует исключение IllegalStateException;
boolean offer(E o) вставляет элемент в очередь, если возможно;
E element() возвращает, но не удаляет головной элемент очереди;
E peek() возвращает, но не удаляет головной элемент очереди, возвращает null, если очередь пуста;
E poll() возвращает и удаляет головной элемент очереди, возвращает null, если очередь пуста;
E remove() возвращает и удаляет головной элемент очереди.
```  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 268  
https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html  

49: Какую математическую сущность моделирует интерфейс `Deque`?  
**Ответ:** Двусторонняя очередь — это линейный набор элементов, который поддерживает вставку и удаление элементов в обеих конечных точках.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html  

50: Какое основное свойство всех имплементаций интерфейса `Deque`, т.е. что их
объединяет независимо от имплементации?  
**Ответ:** Интерфейс `Deque` представляет собой более богатый абстрактный тип данных, чем оба, `Stack` 
и `Queue` потому, что он одновременно реализует и стеки, и очереди. Интерфейс `Deque` определяет методы 
для доступа к элементам на обоих концах `Deque` экземпляра.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html  

51: Какие методы определяет `Deque` в добавок к методам унаследованным от `Queue`?  
**Ответ:** 
```java 
Вставлять
Методы addfirst и offerFirst вставляют элементы в начало Dequeэкземпляра. 
Методы addLast и offerLast элементы вставки в конце Deque экземпляра. 
Когда емкость Deque экземпляра ограничена, предпочтительными методами являются offerFirst и 
offerLast потому что addFirst может не вызвать исключение, если он заполнен.

Удалять
Методы removeFirst и pollFirst удаляют элементы из начала Deque экземпляра. 
Методы removeLast и pollLast удаляют элементы с конца. 
Методы pollFirst и pollLast возвращаются null, если Deque пусто, тогда как методы 
removeFirst и removeLast выдают исключение, если Deque экземпляр пуст.

Забрать
Методы getFirst и peekFirst получить первый элемент Deque экземпляра. Эти методы не удаляют значение из 
Deque экземпляра. Точно так же методы getLast и peekLast извлекают последний элемент. Методы getFirst 
и getLast выдают исключение, если deque экземпляр пуст, тогда как методы peekFirst и peekLast возвращают NULL.
``` 
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html  

52: Верно ли утверждение, что `Queue` всегда обрабатывает элемента в порядке `FIFO`?  
**Ответ:** Очереди обычно, но не обязательно, упорядочивают элементы в порядке FIFO 
(первым поступил – первым обслужен). Исключениями являются приоритетные очереди, которые 
упорядочивают элементы в соответствии с их значениями.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html

53: Какой элемент независимо от упорядочения `Queue` будет удален методами `remove`
и `poll`?  
**Ответ:** Независимо от используемого порядка, в начале очереди находится элемент, 
который будет удален вызовом `remove` или `poll`. В очереди `FIFO` все новые элементы вставляются в 
хвост очереди. В других видах очередей могут использоваться другие правила размещения.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html  

54: Зачем в интерфейсе `Queue` метод `poll`, когда есть `remove`?  
**Ответ:** Методы `remove` и `poll` удаляют и возвращают голову очереди. Какой именно элемент будет 
удален, зависит от политики упорядочивания очереди. Методы `remove` и `poll` отличаются своим поведением 
только тогда, когда очередь пуста. В этих условиях `remove` бросает `NoSuchElementException`, 
а `poll` возвращает `null`.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/queue.html  

55: Какую математическую сущность моделирует интерфейс `Map`?  
**Ответ:** Интерфейс `Map` моделирует абстракцию математической функции.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

56: Какое основное свойство всех имплементаций интерфейса `Map`, т.е. что их
объединяет независимо от имплементации?  
**Ответ:** `Map` — это объект, который сопоставляет ключи значениям. Карта не может содержать 
повторяющиеся ключи: каждый ключ может соответствовать не более чем одному значению.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

57: Реализует ли `Map` интерфейс `Collection`?  
**Ответ:** В отличие от других интерфейсов, которые представляют коллекции, 
интерфейс `Map` НЕ расширяет интерфейс `Collection`.  
**Источник:** https://metanit.com/java/tutorial/5.8.php  

58: Какую структуру данных представляет собой совокупность  
а) ключей;  
б) значений;  
в) пар ключ-значение  
любой имплементации `Map`?  
**Ответ:**
а) Структура данных, представляющая совокупность ключей - `Set` 
метод для получения данной структуры - `keySet()` — возвращает множество(`Set`) ключей;  
б) Структура данных, представляющая совокупность значения - `Collection`
метод для получения данной структуры - `values()` — возвращает коллекцию(`Collection`) значений;  
в) Структура данных, представляющая совокупность пар ключ-значение - `Set`
метод для получения данной структуры - `entrySet()` — возвращает множество(Set) наборов “ключ-значение”.  
**Источник:** https://javarush.ru/groups/posts/2542-otvetih-na-samihe-populjarnihe-voprosih-ob-interfeyse-map  

59: Какие группы операций определены в интерфейсе `Map`?  
**Ответ:**
а) Основные операции  
`Map` (put, get, containsKey, containsValue, size и isEmpty) ведут себя точно 
так же, как их аналоги в `Hashtable`.  
б) Массовые операции интерфейса карты  
Операция `clear` удаляет все сопоставления из файла Map. 
Операция `putAll` является `Map` аналогом работы `Collection` интерфейса `addAll`.  
в) Представления коллекции  
Методы представления коллекции позволяют рассматривать карту как коллекцию тремя способами:  
-`keySet` - набор ключей, содержащихся в карте.  
-`values` - Коллекция значений, содержащихся в карте. Эта коллекция не является набором, поскольку 
несколько ключей могут сопоставлять одно и то же значение.  
-`entrySet` - набор пар ключ-значение, содержащихся в карте. Интерфейс `Map` предоставляет небольшой 
вложенный интерфейс `Map.Entry`, тип элементов этого набора.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

60: Какой интерфейс представляет мультикарту (multimap) в `Collections Framework`?  
**Ответ:** `Java Collections Framework` не включает интерфейс для мультикарт, потому что они не так 
часто используются. Довольно просто использовать a Map, значения которого являются `List` 
экземплярами, в качестве мультикарты.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

61: Дана карта:  
`Map<K, V> map = …;`  
Приведите идиому для выполнения метода `void doAction(K key, V value)` со всеми
элементами карты.  
**Ответ:** 
```java 
public class Runner {
    public static void main(String[] args) {
        Map<K,V> mapForAction = ...;
        mapForAction.put(...);
        mapForAction.put(...);
        mapForAction.put(...);
        for (Map.Entry<K,V> entry : mapForAction.entrySet()){
            doAction(entry.getKey(), entry.getValue());
        }
    }
    private static void doAction(K key, V value){
        System.out.println("Do something whit key and value: " + key + " => " + value);
    }
}
```

62: Дана карта:  
`Map<K, V> map = …;`  
в которой нет элементов со значением `null`.  
Приведите идиому для выполнения метода `void doAction(V value)` с элементом `map`,
заданным ключом `K key`.  
**Ответ:** 
```java 
public class Main {
    public static void main(String[] args) {
          Map<K,V> mapForAction = ...;
        mapForAction.put(...);
        mapForAction.put(...);
        mapForAction.put(...);
        K key = ...;
        if(mapForAction.contains(key)){
        doAction(mapForAction.get(key));
        }
    }

    private static void doAction(int value) {
        System.out.println("Do something whit key and value: " + value);
    }
}
```

63: Дана карта:  
`Map<K, V> map = …;`
в которой есть элементы со значением `null`.  
Приведите идиому для выполнения метода `void doAction(V value)` с элементом map,
заданным ключом `K key`.  
**Ответ:**
```java 
public class Main {
    public static void main(String[] args) {
          Map<K,V> mapForAction = ...;
        mapForAction.put(...);
        mapForAction.put(...);
        mapForAction.put(...);
        K key = ...;
        V value = mapForAction.get(key);
        if(value != null){
        doAction(value);
        }
    }

    private static void doAction(int value) {
        System.out.println("Do something whit key and value: " + value);
    }
}
```

64: Можно ли отрефакторить следующий код?  
Если да, то сделайте это.  
```java 
Purchase purchase = new Purchase("meat", new Byn(100), 10);
for (Map.Entry<Purchase, WeekDay> entry: purchaseWeekDayMap.entrySet()) {
if (entry.getKey().equals(purchase)) {
System.out.println(entry.getKey());
break;
} }
```
**Ответ:** 
```java 
Purchase purchase = new Purchase("meat", new Byn(100), 10);
System.out.println(purchaseWeekDayMap.get(purchase)); //1. В случае, если допускается вывод null как 
                                                      // показателя отсутсвия элемента
if(map.contains(purchase)){                           //2. В случае, если требуется выводить гарантированно имеющийся элемент карты
System.out.println(purchaseWeekDayMap.get(purchase));   
}
```

65: Что возвращает метод `put` интерфейса `Map`?  
**Ответ:** `V put(K key, V value)`— помещает ключ `key` и значение `value` в вызывающую 
карту. При добавлении в карту элемента с существующим ключом произойдет 
замена текущего элемента новым. При этом метод возвратит заменяемый элемент;  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 276  


66: Почему интерфейс `Map` не расширяет интерфейс `Collection` в `Java Collections
Framework`?  
**Ответ:** `Map` - это совокупность пар "ключ"-"значение".
Соответственно некоторые методы интерфейса `Collection` нельзя использовать в `Map`.
Например, метод `remove(Object o)` в интерфейсе `Collection` предназначен для удаления элемента, 
тогда как такой же метод `remove(Object key)` в интерфейсе `Map` - удаляет элемент по заданному ключу.  
**Источник:** https://parshinpn.ru/content/voprosy-i-otvety-na-sobesedovanii-po-teme-java-collection-framework-chast-1  

67: Дайте определение понятию имплементация (Implementation) в контексте
`Collections Framework`.  
**Ответ:** Имплементация — это объекты данных, используемые для хранения коллекций, которые реализуют интерфейсы.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/implementations/summary.html  

68: Какие виды имплементаций можно выделить?  
**Ответ:**
Java `Collections Framework` предоставляет несколько универсальных имплементаций основных интерфейсов:  
а) Для `Set` интерфейса `HashSet` это наиболее часто используемая имплементация.  
б) Для `List` интерфейса `ArrayList` это наиболее часто используемая имплементация.  
в) Для `Map` интерфейса `HashMap` это наиболее часто используемая имплементация.  
г) Для `Queue` интерфейса `LinkedList` это наиболее часто используемая имплементация.  
д) Для `Deque` интерфейса `ArrayDeque` это наиболее часто используемая имплементация.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/implementations/summary.html  

69: На что влияет выбор имплементации?  
**Ответ:** От выбора имплементации напрямую зависят ресурсоемкость, скорость выполнения и производительность.

70: Идиома создания пустой коллекции имеет следующий вид:
`SomeInterface<Entity> entities = new SuitableImplementation<>();`
Почему в левой части идиомы используется ссылка на интерфейс, а не на
имплементацию?  
**Ответ:** Это настоятельно рекомендуемая практика программирования, поскольку она дает вам 
возможность изменять реализации, просто изменяя конструктор. Если какая-либо из переменных, 
используемых для хранения коллекции, или параметры, используемые для ее передачи, объявлены
как имеющие `SomeInterface` тип реализации, а не тип его интерфейса, все такие переменные и параметры 
должны быть изменены, чтобы изменить его тип реализации.   
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  


71: Укажите наиболее часто используемые имплементации для интерфейсов
`Collections Framework`, а также структуру данных, которая поддерживается данной
имплементацией. 
Результат представьте в виде таблицы:
`Interface Implementation Abstract Data Type`
-----------------------------------------------------------------------
**Ответ:**
``` 
Interface Implementation     Abstract Data Type
-----------------------------------------------------------------------
List        ArrayList        структура данных, список, (на основе массива). Как и остальные коллекции
                             имеет свойство саморасширения. Данная реализация хранит проиндексированные объекты. 
                             
            LinkedList       динамически изменяемая структура данных (на базе связанного списка), 
                             состоящая из набора объектов , хранящих ссылки на прерыдущий и следующий объект списка
                            
                           
-----------------------------------------------------------------------
Set         HashSet          Хранит уникальные элементы и допускает наличие null. Элементы 
                             храняться в "корзинах". В корзины элементы распределяются по анализу
                             хэш-кода элемента.

            LinkedHashSet    упорядоченная версия HashSet, которая поддерживает двусвязный 
                             список для всех элементов. Когда необходимо поддерживать порядок итераций.  

            TreeSet          представляет структуру данных в виде дерева, в котором все объекты 
                             хранятся в отсортированном виде по возрастанию.  
-----------------------------------------------------------------------
Map         HashMap          структура данных, которая реализует интерфейс Map<Ключ, 
                             значение>. Элементы как и в HashSet храняться в "корзинах". 
                             В корзины элементы распределяются по анализу
                             хэш-кода элемента.  
 
            LinkedHashMap    упорядоченная реализация хэш-таблицы, в которой имеются 
                             двунаправленные связи между элементами.  

            TreeMap          структура данных, которая реализует Map<Ключ,значение> 
                             интерфейс и основана на красно-черной структуре данных дерева.  
----------------------------------------------------------------------- 
Queue      LinkedList        динамически изменяемая структура данных (на базе связанного списка), 
                             состоящая из набора объектов , хранящих ссылки на прерыдущий и следующий объект списка
----------------------------------------------------------------------- 
Deque      LinkedList        динамически изменяемая структура данных (на базе связанного списка), 
                             состоящая из набора объектов , хранящих ссылки на прерыдущий и следующий объект списка                                   
```

72: Приведите идиому создания очереди.  
`Xxx<Integer> queue = ...;`
Xxx - это подходящий интерфейс.  
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.  
**Ответ:** 
```java 
  Queue<Integer> queue = new LinkedList<Integer>();
  queue.add(7);
  queue.add(12);
  queue.add(2);
  queue.pop();
  System.out.println(queue);
```

73: Приведите идиому создания стека. 
`Xxx<Integer> stack = ...;`
Xxx - это подходящий интерфейс.  
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.  
**Ответ:** 
```java 
Deque<Integer> stack = new ArrayDeque<Integer>();
stack.push(2);
stack.push(5);
stack.push(1);
stack.remove(2);
System.out.println(stack);
```

74: Когда целесообразно использовать реализацию `TreeSet` вместо `HashSet`?  
**Ответ:** `HashSet`, который хранит свои элементы в хеш-таблице, является наиболее 
эффективной реализацией. Однако он не дает никаких гарантий относительно порядка итерации. 
`TreeSet`, который хранит свои элементы в красно-черном дереве, упорядочивает свои элементы на 
основе их значений. Такая реализация существенно медленнее, чем `HashSet`. 
Исходя из этого можно сделать вывод, что если в приоритете задачи стоит упорядоченность множества, а
не скорость выполнения, стоит использовать `TreeSet`.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html  

75: Опишите неупорядоченные реализации `Map`.  
**Ответ:** `HashSet` хранит свои элементы в хеш-таблице и является наиболее эффективной 
реализацией. Однако он не дает никаких гарантий относительно порядка итерации.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

76: Опишите упорядоченные реализации `Map`.  
**Ответ:** `TreeMap` хранит свои элементы в красно-черном дереве и упорядочивает свои 
элементы на основе их значений.  
`LinkedHashMap` который реализован как хэш-таблица с проходящим через нее связанным списком, 
упорядочивает свои элементы в соответствии с порядком, в котором они были вставлены в 
набор (порядок вставки). `LinkedHashMap` избавляет своих клиентов от неопределенного, как правило, 
хаотического упорядочения, обеспечиваемого по `HashMap`.   
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

77: Чем отличается `ArrayList` и `LinkedList`?  
**Ответ:**  
Преимущества `ArrayList`: в возможности доступа к произвольному элементу по индексу за 
постоянное время (так как это массив), минимум накладных расходов при хранении такого списка, 
вставка в конец списка в среднем производится так же за постоянное время.  
Недостатки `ArrayList` проявляются при вставке/удалении элемента в середине списка — это взывает 
перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме того, 
при удалении элементов размер массива не уменьшается, до явного вызова метода `trimToSize()`.  
`LinkedList` наоборот, за постоянное время может выполнять вставку/удаление элементов в списке 
(именно вставку и удаление, поиск позиции вставки и удаления сюда не входит). 
Доступ к произвольному элементу осуществляется за линейное время (но доступ к первому и последнему
элементу списка всегда осуществляется за константное время — ссылки постоянно хранятся на первый и 
последний, так что добавление элемента в конец списка вовсе не значит, что придется перебирать весь 
список в поисках последнего элемента).  
`LinkedList` предпочтительно применять, когда происходит активная работа (вставка/удаление) с 
серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.  
**Источник:** https://habr.com/ru/post/162017/  

78: Что такое вычислительная сложность операции (алгоритма)?  
**Ответ:** Количество элементарных операций, затрачиваемых алгоритмом для решения конкретной задачи. 
Сложность зависит не только от размерности входных данных, но и от самих данных. 
Очевидно, что чем сложнее алгоритм в вычислительном плане, тем больше времени и вычислительных 
ресурсов потребует его выполнение.  
**Источник:** https://wiki.loginom.ru/articles/computational-complexity.html  

79: Укажите вычислительную сложность для операций получения элемента по
индексу, поиска, вставки и удаления, для основных коллекций.  
**Ответ:** 
```java 
                             Худшее                                            Среднее
                     Индекс  Поиск     Вставка     Удаления          Индекс  Поиск     Вставка     Удаления     
ArrayList             O(1)   O(n)       O(n)       O(n)               O(1)   O(n)       O(n)       O(n)             
Vector                O(1)   O(n)       O(n)       O(n)               O(1)   O(n)       O(n)       O(n)              
LinkedList            O(n)   O(n)       O(1)       O(1)               O(n)   O(n)       O(1)       O(1)       
HashTable             n/a    O(n)       O(n)       O(n)               n/a    O(1)       O(1)       O(1)            
HashMap               n/a    O(n)       O(n)       O(n)               n/a    O(1)       O(1)       O(1)                 
LinkedHashMap         n/a    O(n)       O(n)       O(n)               n/a    O(1)       O(1)       O(1)            
TeeMap                n/a    O(log(n))  O(log(n))  O(log(n))          n/a    O(log(n))  O(log(n))  O(log(n))        
HashSet               n/a    O(n)       O(n)       O(n)               n/a    O(1)       O(1)       O(1)         
LinkedHashSet         n/a    O(n)       O(n)       O(n)               n/a    O(1)       O(1)       O(1)       
TreeSet               n/a    O(log(n))  O(log(n))  O(log(n))          n/a    O(log(n))  O(log(n))  O(log(n)) 
``` 
**Источник:** https://habr.com/ru/post/237043/  

80: В чем разница между интерфейсами `Comparable` и `Comparator`?  
**Ответ:**  
`Comparable` - это интерфейс, доступный в пакете `java.lang`. Класс реализует интерфейс `Comparator` 
для сортировки своего объекта в естественном порядке. Сортировка объектов в естественном порядке 
означает, что объекты сравниваются по их значениям `ASCII`.  
Компаратор - это интерфейс, доступный в пакете `java.util`. Интерфейс `Comparator` не реализован в классе, 
объекты которого должны сравниваться, вместо этого отдельный класс реализует интерфейс `Comparator`, 
так что логика сортировки применяется к каждому элементу данных объекта в другом классе.  
**Источник:** https://ru.living-in-belgium.com/difference-between-comparable-and-comparator-in-java-381  


81: В чем разница между `Iterator` и `ListIterator`?  
**Ответ:** Интерфейс `ListIterator<E>` расширяет интерфейс `Iterator<E>` и предназначен для обработки 
списков и их вариаций.  
Интерфейс `Iterator` предоставляет `remove` операцию по удалению последнего элемента, возвращенного 
`next` из файла `Collection`. Для `ListIterator` эта операция удаляет последний элемент, возвращенный 
`next` или `previous`. Интерфейс `ListIterator` предоставляет две дополнительные операции для модификации 
списка — `set и add`.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html  
И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 261  

82: Почему в классе `Iterator` нет метода для получения следующего элемента без
передвижения курсора?  
**Ответ:** Итератор похож на указатель своими основными операциями: он указывает на отдельный 
элемент коллекции объектов (предоставляет доступ к элементу) и содержит функции для перехода к 
другому элементу списка (следующему или предыдущему). Контейнер, который реализует поддержку 
итераторов, должен предоставлять первый элемент списка, а также возможность проверить, перебраны 
ли все элементы контейнера (является ли итератор конечным). Таким образом без курсора просто 
нельзя будет реализовать безошибочное передвижение по коллекции.  
**Источник:** https://javastudy.ru/interview/collections/  

83: Назовите высокопроизводительные реализации `Set` для перечислимых типов (enum)?  
**Ответ:** Абстрактный класс `EnumSet<E extends Enum<E>>` наследуется от абстрактного 
класса `AbstractSet`. Класс специально реализован для работы с типами enum. Все элементы такой 
коллекции должны принадлежать единственному типу enum, определенному явно или неявно.  
**Источник:** И. Н. Блинов, В. С. Романчик Java Методы программирования Учебно-методическое пособие 2013 стр. 274  


84: Как происходит удаление элементов из `ArrayList`? Как меняется в этом случае
размер `ArrayList`?  
**Ответ:** Недостатки `ArrayList` проявляются при вставке/удалении элемента в середине списка — 
это взывает перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме 
того, при удалении элементов размер массива не уменьшается, до явного вызова метода `trimToSize()`.   
**Источник:** https://habr.com/ru/post/162017/  

85: Можно ли использовать массив в качестве ключа для `HashMap`? 
Если да, то какие есть особенности.  
**Ответ:** Хеш-код массива не зависит от хранимых в нем элементов, а присваивается при создании 
массива (метод вычисления хеш-кода массива не переопределен и вычисляется по стандартному 
`Object.hashCode()` на основании адреса массива). Так же у массивов не переопределен `equals` и 
выполняет сравнение указателей. Это приводит к тому, что обратиться к сохраненному с 
ключом-массивом элементу не получится при использовании другого массива такого же размера и с 
такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой 
ссылки на массив, что использовалась для сохранения элемента.  
**Источник:** https://habr.com/ru/post/162017/  

86: Где определены полиморфные алгоритмы для работы с коллекциями? Опишите
основные группы.  
**Ответ:** Полиморфные алгоритмы представляют собой фрагменты повторно используемых функций, 
предоставляемых платформой `Java`. Все они исходят из `Collections` класса и все имеют форму статических
методов, первый аргумент которых — коллекция, над которой должна выполняться операция. 
Подавляющее большинство алгоритмов, предоставляемых платформой Java, работают с `List` экземплярами, 
но некоторые из них работают с произвольными `Collection` экземплярами.  
**Источник:** https://docs.oracle.com/javase/tutorial/collections/algorithms/index.html  

87: В чем заключается назначение метода
`Collections.unmodifiableCollection(Collection<? extends T> c)`?  
**Ответ:** Метод `unmodifiableCollection ()` класса `java.util.Collections` используется для возврата 
неизменяемого представления указанной коллекции. Этот метод позволяет модулям предоставлять 
пользователям доступ «только для чтения» к внутренним коллекциям. Операции запроса в возвращенной 
коллекции «читаются» в указанной коллекции и пытаются изменить возвращенную коллекцию, либо 
напрямую, либо через ее итератор, что приводит к исключению `UnsupportedOperationException`.  
**Источник:** http://espressocode.top/collections-unmodifiablecollection-method-in-java-with-examples  

88: Перечислите различия между массивами и коллекциями?  
**Ответ:**
Массивы - это простые конструкции фиксированного размера, и поэтому они могут хранить только 
заданное количество элементов.  
Массивы встроены в ядро языка Java, и используемый при работе с ними синтаксис Java очень прост и 
понятен. Например, чтобы получить элемент массива с номером n, вам нужно вызвать функцию array[n].  
Коллекции - это более сложный, но в то же время более гибкий тип данных.  
Прежде всего, размер коллекции можно изменять: вы можете добавлять в коллекцию любое количество
элементов.  
Коллекции автоматически обрабатывают удаление элемента из любой позиции.  
В языке Java существует несколько типов коллекций с различной внутренней структурой хранения 
(линейная, список, хэш-набор, дерево элементов и другие).  
**Источник:** https://help.anylogic.ru/index.jsp?topic=%2Fcom.anylogic.help%2Fhtml%2Fcode%2Farrays-collections.html  

89: Массивы и коллекции являются ковариантными или инвариантными?
Поясните ответ.  
**Ответ:**
Массивы ковариантны. Это означает, что если Sub является подтипом `Super`, то тип массива `Sub[]` 
является подтипом `Super[]`. 
Обобщенные типы, напротив, инвариантны: для любых двух различных типов `Type1` и `Туре2` тип `List` 
не является ни подтипом, ни супертипом `List`.  
**Источник:** Д.Блох. Java: Эффективное программирование, 3-е издание 2019 года. стр. 168  

90: Дано:
`SortedSet<Entity> set = ...;`
Найдите в jdk
а) тип 1, для которого `SortedSet<Entity>` является подтипом.
б) подтип 2 для `SortedSet<Entity>`.
Создайте множество `set1` типа 1 и множество `set2` подтипа 2. Проверьте
правильность, сделав присваивания:  
`set1 = set;`
`set = set2;`  
**Ответ:** 
```java 
SortedSet<Entity> set = new TreeSet<>();        
а) Set<Entity> set1 = new HashSet<>();        
б) SortedSet<Entity> set2 = new NavigableSet<>();  
System.out.println(set1 = set); \\ true  
System.out.println(set = set2); \\ true
```  

91: Массивы и коллекции являются `reified` (овеществленные) или `non-reified` типами?
Поясните ответ.  
**Ответ:**  
Массивы являются типами, доступными при выполнении (`reified`). Это значит, что массивы знают 
тип элементов во время выполнения и обеспечивают его.  
Обобщенные типы, напротив, реализуются с использованием затирания (`erasure`). Это значит, что они 
обеспечивают ограничения на типы только на этапе компиляции, а затем отбрасывают (или затирают) 
информацию о типах элементов при выполнении.  
**Источник.** Д.Блох. Java: Эффективное программирование, 3-е издание 2019 года. стр. 169  