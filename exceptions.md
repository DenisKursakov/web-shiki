**Questions**  

1. Что такое исключения?  
**Ответ:**  Это сигнал о нестандартной – исключительной – ситуации. Ситуации могут быть самые различные – ожидаемые или нет, разной степени критичности. 
И относиться к этим ситуациям, естественно, приходится по-разному.
Как и всё в Java, исключения тоже представленны в виде классов. 
Корнем иерархии служит класс ```java.lang.Throwable```, дословно – "бросаемый". 
Его прямыми наследниками являются ```java.lang.Exception``` и ```java.lang.Error```, от которых и 
унаследованы все остальные исключения. И от которых рекомендуется наследовать собственные.  
**Источник:** http://skipy.ru/technics/exceptions.html  
   
2. Какие действия производит система времени выполнения при возникновении исключения?  
**Ответ:** В отличие от проверяемых исключений, класс
```RuntimeException``` и порожденные от него классы относятся к непроверяемым
исключениям. Компилятор не проверяет, может ли генерировать и/или обрабатывать метод эти исключения. Исключения типа ```RuntimeException``` генерируются при возникновении ошибок во время выполнения приложения.  
**Источник:**  Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 202  
   
3. Как называется блок кода, который обрабатывает исключение?  
**Ответ:** Блок предназначенный для обработки исключений называется ```catch```  
   
4. Как реализуется требование «Поймай или Укажи» (Catch or Specify)?  
**Ответ:** Допустимый код языка программирования Java должен соответствовать требованиям ```Catch or Specify Requirement``` . Это означает, что код, который может вызывать определенные исключения, должен быть заключен в одно из следующих условий:
```try``` Утверждение , что перехватывает исключение. ```try``` Должен предоставить обработчик исключения, как описано в отлове и Обработка исключений .
Метод, указывающий, что он может вызвать исключение. Метод должен предоставить ```throws``` предложение, в котором перечислены исключения, как описано в разделе «Указание исключений, создаваемых методом» .
Код, который не соответствует требованиям ```Catch or Specify Requirement```, не будет компилироваться.
Не все исключения подпадают под требования «Поймать или указать».  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html  
   
5. Какая иерархия классов исключений?  
**Ответ:** Все исключения являются наследниками суперкласса ```Throwable``` и его подклассов ```Error```
и ```Exception``` из пакета ```java.lang```. Исключения класса ```RuntimeException```  наследуются от класса ```Exception```.  
**Источник:**  Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 202
   
6. Какие виды исключений относятся к непроверяемым?  
**Ответ:**
В отличие от проверяемых исключений, класс ```RuntimeException``` и порожденные от него классы относятся к непроверяемым
исключениям. Компилятор не проверяет, может ли генерировать и/или обрабатывать метод эти исключения. Исключения типа ```RuntimeException``` генерируются при возникновении ошибок во время выполнения приложения.  
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 202


7. Какие компоненты могут входить в обработчик исключений?  
**Ответ:** Для обработки исключений ```java``` используются следующие операторы: ```try, catch, finally, throw, throws```. Первые три - стандартная структура вашего блока. По шагам:  
1)Оператор или часть кода, в которой вам надо отыскать ошибку, помещается в блок ```try```.
2)Далее в блоке ```catch``` вы указываете, что за исключение надо ловить и как его обрабатывать.
3)В блоке ```finally``` набор обязательных действий при возникновении ошибки. Обычно это запись данных, закрытие ресурсов и пр. Блок исполняется всегда, вне зависимости от срабатывания ```catch```.  
**Источник:** https://periscopes.ru/sozdanie-isklyuchenii-java-isklyucheniya-java.html  
   
8. Для каких ситуаций используется оператор ```try-with-resources```?  
**Ответ:** Конструкция ```try-with-resources``` дает возможность объявлять один или несколько ресурсов в блоке ```try```, которые будут закрыты автоматически без использования ```finally``` блока.
В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс ```java.lang.AutoCloseable``` или ```java.io.Closable```.
Если ```try``` блок также выбрасывает исключение, оно побеждает, а исключение из ```close()``` метода подавляется.  
**Источник:** https://www.examclouds.com/ru/java/java-core-russian/try-with-resources  
   
9. Какой код заключается в блок ```try```?
**Ответ:** Оператор или часть кода, в которой вам надо отыскать ошибку, помещается в блок ```try```.  
**Источник:** https://periscopes.ru/sozdanie-isklyuchenii-java-isklyucheniya-java.html  
   
10. Выполняется ли весь код блока ```try``` в случае возникновения исключения?  
**Ответ:**  Сначала выполняется код внутри блока ```try {...}```.  
Если в нём нет ошибок, то блок ```catch(err)``` игнорируется: выполнение доходит до конца ```try``` и потом далее, полностью пропуская ```catch```.  
Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало ```catch(err)```. Переменная ```err``` (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.  
  
11. Может ли использоваться только один блок ```try``` (без ```catch``` или ```finally```)?  
**Ответ:** У каждого раздела ```try``` должен быть по крайней мере или один раздел catch или блок ```finally```. 
Блок ```finally``` очень удобен для закрытия файлов и освобождения любых других ресурсов, захваченных для временного использования в начале выполнения метода.  
Однако операторы ```try``` можно вкладывать друг в друга. При этом если вложенный обработчик не имеет своего блока ```catch```, он осуществляет его поиск в родительском операторе. Если и там нет – блок обрабатывается системой.  
**Источник:** http://java-online.ru/java-throws.xhtml  
    
12. Какое назначение блока ```catch```?  
**Ответ:** Ближайший окружающий блок ```try``` проверяется на наличие соответствующего возбужденному исключению обработчика ```catch```. Если такой отыщется, управление передается ему. 
В блоке ```catch``` мы указываем, что за исключение надо ловить и как его обрабатывать.
Блок ```catch(){} ```похож на метод, принимающий в качестве единственного параметра ссылку на объект-исключение и обрабатывающий этот объект  
**Источник:** https://periscopes.ru/sozdanie-isklyuchenii-java-isklyucheniya-java.html  
Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 205


13. Сколько блоков ```catch``` может содержаться после ```try-оператора```?  
**Ответ:** Если в блоке ```try``` может быть сгенерировано в разных участках кода несколько типов исключений, то необходимо наличие нескольких блоков ```catch```, если только блок ```catch``` не обрабатывает все типы исключений.   
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 206  
    
14. Если применяется несколько блоков `catch`, то в каком порядке в случае возникновения исключения они вызываются?  
**Ответ:** Подклассы исключений в блоках `catch` должны следовать перед любым
из их суперклассов, иначе суперкласс будет перехватывать эти исключения.
Например:
```java 
try { /* код, который может вызвать исключение */
} catch(IllegalArgumentException e) {
} catch(PatternSyntaxException e) { } /* никогда не может быть вызван: ошибка компиляции */
```
где класс ```PatternSyntaxException``` представляет собой подкласс класса
```IllegalArgumentException```.  
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 206-207  

15. Какой код может быть между блоками `try` и `catch`?  
**Ответ:** Предположим , что это допустимо Java (это не компилирует):
```java 
try {
throw new Exception();
}
System.out.println("Sup!");
catch(Exception e) { }
```
Когда возникает исключение, строка, которая выводит `Sup!` , все равно будет пропущена, поскольку 
```JVM``` ищет, чтобы перейти к соответствующему обработчику исключений для обработки ```Exception``` . 
Таким образом, в некотором смысле код ведет себя так же, как если бы он находился в самом блоке t```ry {}```, 
поэтому на самом деле не имеет значения, где он находится, и Java указывает, что эта ( теперь доказанная бесполезность ) 
конструкция является незаконной. Исходя из примера становится понятно что между блоками `try` и `catch` не может быть кода.  


16. Может ли использоваться блок ```catch``` без блока ```try```?   
**Ответ:** Невозможно иметь блок ```catch``` без ```try```. Блок ```try``` передает ошибку блоку ```catch``` 
соответственно если блок ```try``` отсутствует то блоку ```catch``` исключение передано не будет, в таком случае его наличие бессмысленно.  


17. Сколько типов исключений может обрабатывать один блок ```catch```?  
**Ответ:** ```Multi-catch``` блок может содержать только исключения не входящие в одну иерархию. 
Один ```catch``` блок может обрабатывать несколько типов исключений прописанных через '|' в параметрах блока, так же обрабатывая наследников указанных исключений.  

18. В случае отсутствия исключения в блоке ```try``` выполняется ли блок ```catch```?  
**Ответ:** Нет, т.к. блок ```try``` передает исключение в блок ```catch``` соответственно при остутсвии исключения блок ```catch``` не будет запущен.  

19. Для чего используется блок ```finally```?  
**Ответ:** Блок ```finally``` идет в самом конце конструкции ```try/catch/finally```.
Возможна ситуация, при которой нужно выполнить некоторые действия
по завершению программы (закрыть поток, освободить соединение с базой
данных) вне зависимости от того, произошло исключение или нет. В этом
случае используется блок ```finally```, который обязательно выполняется после инструкций ```try``` или ```catch```.   
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 211  


20. В случае отсутствия исключения в блоке `try` выполняется ли блок `finally` (при его наличии)?  
**Ответ:** Ключевая особенность блока ```finally``` заключается в том, 
что он выполняется обязательно после инструкций ```try``` или ```catch.```, вне зависимости от того, сработал ```catch``` или нет.   
**Источник:** http://skipy.ru/technics/exceptions.html#rex  
    
21. Могут ли использоваться блоки `try-finally `без блока `catch`?  
**Ответ:** Да. Ключевое слово ``finally`` создаёт блок кода, который будет выполнен после завершения блока 
``try/catch``, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того, 
передано исключение или нет. Оператор ``finally`` не обязателен, однако каждый оператор ``try`` требует 
наличия либо ``catch``, либо ``finally``.  
**Источник:** http://developer.alexanderklimov.ru/android/java/exception.php  

22. Приведите пример кода, в котором используется оператор `try-with-resources`.  
**Ответ:**  
В следующем примере считывается первая строка из файла. Он использует экземпляр `BufferedReader` для 
чтения данных из файла. ``BufferedReader``- это ресурс, который необходимо закрыть после того, 
как программа завершит работу с ним:
```java 

static String readFirstLineFromFile (String path) выдает исключение IOException {
     try (BufferedReader br =
                   new BufferedReader (новый FileReader (путь))) {
        вернуть br.readLine ();
    }
}
```
В этом примере ресурс, объявленный в `try` операторе `-with-resources`, является файлом `BufferedReader`. 
Оператор объявления появляется в круглых скобках сразу после `try` ключевого слова.
Поскольку `BufferedReader` экземпляр объявлен в операторе `try-with-resource`, он будет закрыт независимо от того, 
`try` завершается ли оператор нормально или внезапно (в результате того, что метод `BufferedReader.readLine` выбрасывает `IOException`).  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  

23. Какой оператор может использоваться вместо `try-with-resources`?  
**Ответ:** До `Java SE 7` можно было использовать `finally` блок, чтобы гарантировать, что ресурс закрыт, независимо от того, `try` завершается ли оператор нормально или внезапно.  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  
    
24. Может ли применяться оператор `try-with-resources` совместно с блоком `finally`?  
**Ответ:** 
Оператор `try-with-resources` может иметь `catch и finally` блокировать, как обычный `try` оператор. 
В операторе `try-with-resources` любой блок `catch` or `finally` запускается после закрытия объявленных ресурсов.
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  
    
25. Какое ключевое слово используется в сигнатуре метода, чтобы указать на возможность выбрасывания им исключения?  
**Ответ:**  Когда вы не планируете обрабатывать исключение в своем методе, но хотите предупредить 
пользователей метода о возможных исключительных ситуациях — используйте ключевое слово `throws`. Это ключевое слово в сигнатуре метода означает, что при определенных условиях метод, может выбросить исключение  
**Источник:** https://javarush.ru/groups/posts/isklyucheniya-java  
    
26. Сколько исключений может выбрасывать метод?  
**Ответ:** Нет никаких ограничений относительно того, сколько исключений может быть вызвано методом.  
**Источник:** 

27. Какое ключевое слово используется для гарантированного выбрасывания исключения?  
**Ответ:** Все методы используют этот `throw` оператор для создания исключения. Для этого `throw` 
утверждения требуется единственный аргумент: метательный объект. Метательные объекты - это экземпляры любого подкласса `Throwable` класса. Вот пример `throw` утверждения.
```java 
throw someThrowableObject ;
```  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html  

28. Можно ли создавать свои собственные классы исключений?  
**Ответ:** Да, более во многих ситуациях рекомендуется создание собственного исключения.
Для повышения качества и скорости восприятия кода разработчик может создать собственное исключение как подкласс класса `Exception` и затем
использовать его при обработке ситуации, не являющейся исключением с точки зрения языка, но нарушающей логику вещей. По соглашению наcледник
любого класса-исключения должен заканчиваться словом `Exception`.  
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 212  
    
29. Приведите примеры наиболее известных подклассов класса `Exception`.  
**Ответ:** 
```java 
IOException
IllegalAccessException
ClassNotFoundException
RuntimeException
NoSuchFieldException
NoSuchMethodException
```
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 203  


30. Приведите примеры наиболее известных подклассов класса `RuntimeException`.  
**Ответ:** 
```java 
ArithmeticException - Арифметическая ошибка: деление на ноль и др.  
ArrayIndexOutOfBoundsException - Индекс массива находится вне его границ  
ArrayStoreException - Назначение элементу массива несовместимого типа  
ClassCastException - Недопустимое приведение типов  
ConcurrentModificationException - Некорректный способ модификации коллекции  
IllegalArgumentException - При вызове метода использован некорректный аргумент  
IllegalMonitorStateException - Незаконная операция монитора на разблокированном   
объекте  
IllegalStateException - Среда или приложение находятся в некорректном   
состоянии  
IllegalThreadStateException - Требуемая операция не совместима с текущим   
состоянием потока  
IndexOutOfBoundsException - Некоторый тип индекса находится вне границ коллекции  
NegativeArraySizeException - Попытка создания массива с отрицательным размером  
NullPointerException - Недопустимое использование  ссылки  на null  
NumberFormatException - Невозможное преобразование строки в числовой формат  
StringIndexOutOfBoundsException - Попытка индексации вне границ строки  
MissingResourceException - Отсутствие файла ресурсов properties или имени   
ресурса в нем  
EnumConstantNotPresentException - Несуществующий элемент перечисления  
UnsupportedOperationException - Встретилась неподдерживаемая операция  
```
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 204  

31. Что такое сцепление исключений?  
**Ответ:** В тех случаях, когда исключение нижнего уровня может быть полезно при анализе ситуации,
вызвавшей исключение, лучше использовать особый вид трансляции исключений, называемый
сцеплением исключении (exception chaining). При этом исключение нижнего уровня передается с
исключением верхнего уровня; в последнем создается открытый метод доступа, позволяющий извлечь
исключение нижнего уровня  
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 168.  

32. Приведите пример кода со сцеплением исключений.  
**Ответ:** 
```java 
try { 
// Использование абстракции нижнего уровня 
// для выполнения наших указаний 
} catch(LowerLevelException е) { 
throw new H1gherLevelException(e); 
}
```
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 168.  

33. Какая информация приводится при трассировке стека во время исключения?  
**Ответ:** Если выполнение программы завершается аварийно из-за необработанного исключения, система
автоматически распечатывает трассировку стека для этого исключения. Трассировка стека содержит
строковое представление данного исключения, результат вызова его метода `toString`.  
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 171.  

34. В каких случаях целесообразно создавать собственный класс исключения?  
**Ответ:** Для повышения качества и скорости восприятия кода разработчик может создать собственное исключение как подкласс класса `Exception` и затем
использовать его при обработке ситуации, не являющейся исключением с точки зрения языка, но нарушающей логику вещей.  
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 212  

35. Какой класс исключений может использоваться в качестве суперкласса для собственного исключения?  
**Ответ:** Класс `Exception` и его потомки могут использоваться в качестве супперкласса для собственных исключений.   
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 212  

36. Какие исключения целесообразно делать проверяемыми, а какие – непроверяемыми?  
**Ответ:** Исключения-наследника от класса `Exception` целесообразно делать проверяемыми,
от `RuntimeException` - непроверяемыми. 
**Источник:** http://www.quizful.net/post/java-exceptions  

37. Какие преимущества в механизме выбрасывания и обработки исключений?   
**Ответ:**  
а) Разделение Кода Обработки ошибок от "Регулярного" Кода  
б) Возможностью распространить сообщение об ошибке стек вызовов методов.  
в) Группировка и Дифференциация Ошибочных Типов  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html    

38. Можно ли выбрасывать исключения в конструкторах?  
**Ответ:** Для конструкторов - да: вы должны генерировать исключение из конструктора всякий раз, когда вы не можете должным образом инициализировать (построить) объект.  
**Источник:** https://isocpp.org/wiki/faq/exceptions#ctors-can-throw  

39. Может ли произойти потеря исключения? Если да – приведите пример.  
**Ответ:**   Блок ``finally`` может вызвать потерю исключений. Пример:  
```java 
import java.io.IOException;

/**
 * ExceptionLossTest
 */
public class ExceptionLossTest{

    public static void main(String[] args){
        try {
            try {
                throw new Exception("a");
            } finally {
                if (true) {
                    throw new IOException("b");
                }
                System.err.println("c");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("d");
            System.err.println(ex.getMessage());
        }
    }
}
```  
После инициации первого исключения – `new Exception("a")` – будет выполнен блок `finally`, в котором будет брошено исключение new ```IOException("b")```. И именно это исключение будет поймано и обработано. Исходное же исключение теряется.  
**Источник:** http://www.skipy.ru/technics/exceptions.html   

40. Обладают ли исключения свойством транзакционности?  
**Ответ:** Cвойством транзакционности исключения не обладают – действия, произведенные в блоке `try` до возникновения исключения, не отменяются поcле его возникновения.  
**Источник:** http://www.skipy.ru/technics/exceptions.html#no_trans  

41. Является ли данный код антипаттерном?  
    Обоснуйте ответ.
```java
void methodCatchesSomeException() {
...
try {
...
} catch (SomeException ex) {
...
}
...
}
```
**Ответ:** Нет, блок `try` и `catch` объявлены в методе верно, исключение (при его наличии) будет перехвачено.  

42. Является ли данный код антипаттерном?
Обоснуйте ответ.
```java 
void methodThrowsSomeCheckedException() {
...
throw new SomeCheckedException();
...
}
```  
**Ответ:** Да, у данного метода отсутствует объявление исключения в секции `throws` и передача вызывающему методу.   

43. Является ли данный код верным? Укажите почему.
```java 
void methodThrowsSomeCheckedException() throws SomeCheckedException {
...
throw new SomeCheckedException();
...
}
```   
**Ответ:** Код является верным т.к., в теле метода прописана генерация исключения которое в секции `throws` передает исключение вызывающему методу.  

44. Приведите примеры кода с выбросом `RuntimeException` явным образом и в случае программной ошибки.  
**Ответ:** 
```java 
public class RuntimeChecker {   
// явным образом  
    void methodThrowsSomeRuntimeException() {  
        throw new ArrayIndexOutOfBoundsException;
    }  
// в случае программной ошибки  
    void methodWithSomeRuntimeException() {  
        String[] someArray = new String[5];  
        String elementsWithTenId = someArray[10]; // result - ArrayIndexOutOfBoundsException   
    }  
}
```

46. Можно ли отрефакторить данный код? Если да, то выполните.  
```java 
void methodThrowsSomeRuntimeException() {
...
throw new SomeRuntimeException();
...
}
```  
**Ответ:** Можно добавить информацию об ошибке при генерации исключения `SomeRuntimeException()`.  

46. Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java 
void methodThrowsSomeRuntimeException() throws SomeRuntimeException {
...
throw new SomeRuntimeException();
...
}
```  
**Ответ.** Да, данный код - антипаттерн. Для исключений-подклассов класса RuntimeException (unchecked) 
используемых для отображения программных ошибок, при выполнении приложения в объявлении 
метода секция throws может отсутствовать, так как играет только информационную роль.   
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 276 с.  


47. В какой версии ``Java`` появился оператор ``try-with-resources``? Приведите пример кода с использованием указанного оператора.  
**Ответ:** Конструкцию `try-with-resources` ввели в `Java 7`. Пример: 
```java 
static String readFirstLineFromFile(String path) throws IOException {
    try (BufferedReader br =
                   new BufferedReader(new FileReader(path))) {
        return br.readLine();
    }
}
```
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  

48. Является ли данный код антипаттерном?
Обоснуйте ответ.
```java 
void methodWithAutocloseableInstance() {
...
try(SomeResource res = new SomeResource(...)) {
...
}
...
}
```
**Ответ:** Да. В данном коде отсутсвуют блоки `catch` и `finally`. Блок `try` обязательно должен иметь блок `catch` или `finally`.  

49. Является ли данный код антипаттерном?
Обоснуйте ответ.
```java 
void methodWithAutocloseableInstance() {
...
try(SomeResource res = new SomeResource(...)) {
...
} catch (CorrectCheckedException ex) {
…
}
...
}
```  
**Ответ:** Нет, код корректный. Используется `try-with-resources` соответственно все ресурсы будут зыкрыты, 
блок `catch` для обработает исключения.  

50. Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java 
try {
…
}  catch (SomeException е) {
//no code
}
```  
**Ответ:** Пустой блок `catch` лишает исключение смысла, который состоит в том, чтобы вы
обрабатывали исключительную ситуацию. Блок `catch` обязан содержать, по крайней мере,
комментарий, объясняющий, почему данное исклю чение следует игнорировать.  
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 175.  

51. Является ли данный код антипаттерном?  
Обоснуйте ответ.
```java 
try {
…
}  catch (SomeException е) {
System.out.println(“Something went wrong!”);
}
``` 
**Ответ:**  Нет, если данный код предназначен для логирования исключений.  

52. Является ли данный код антипаттерном, если блок `catch` находится не в конце раннер-метода `main()`?  
Обоснуйте ответ.
```java 
try {
…
}  catch (Exception е) {
…
}
…

или другой вариант

try {
…
}  catch (Throwable е) {
…
}
…
```  
**Ответ:** Нет, блок `catch` может находиться не в конце раннер-метода `main()`. 
Однако не используйте `Exception, RuntimeException, Throwable и Error` непосредственно. Рассматривайте эти классы как если бы они были абстрактными. Нельзя надежно протестировать эти исключения, поскольку они являются суперклассами для других исключений, которые может генерировать метод.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 368 с.  

53. Является ли данный код антипаттерном?  
Обоснуйте ответ.
```java 
try {
int i = 0;
while(true) {
а[i++].f();
}
} catch(ArraylndexOutOfBoundsException е) {
…
}
```  
**Ответ:** `ArrayIndexOutOfBoundsException` - относится к `RuntimeException` такого типа исключения нельзя перехватывать, т.к. в большинстве случаев это ошибка программирования, и подобным образом она скрывается.  

54. Есть ли недостатки у `API` написанного только с использованием обрабатываемых исключений?  
**Ответ:** 
Такое решение оправданно, если даже при надлежащем применении интерфейса `API` невозможно
предотвратить возникновение условий для исключительной ситуации, однако программист,
пользующийся данным `API`, столкнувшись с этим исключением, мог бы предпринять какие-либо
полезные действия. Если не выполняются оба этих условия, лучше пользоваться необрабатываемым
исключением.  
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 163.  

55. Даны два варианта сеттера.
Какой является более предпочтительным в использовании?  
Обоснуйте ответ.
```java 
Вариант 1.
void setPositiveValue(int value) {
if(value <= 0) {
throw new IllegalArgumentException(...);
}
this.value = value;
}
Вариант 2.
void setPositiveValue(int value) throws SomeCheckedException {
if(value <= 0) {
throw new SomeCheckedException(...);
}
this.value = value;
}
```
**Ответ.** Вариант 1.  
Повторное использование имеющихся исключений имеет ряд преимуществ.   
Главное среди них то, что они упрощают изучение и применение ваших `API`, поскольку соответствуют установленным соглашениям, с которыми хорошо знакомы программисты. 
С этим же связано второе преимущество, заключающееся в том, что программы, использующие ваш `API`, проще для чтения и понимания, поскольку в них нет незнакомых, сбивающих с толку исключений. 
Наконец, чем меньше классов исключений, тем меньше требуется места в памяти и времени на их загрузку.    
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 367 с.

56. Приведите пример наиболее распространенных из повторно используемых исключений и причины их применения.  
**Ответ:**
Чаще всего используется исключение `IllegalArgumentException`. Обычно оно генерируется, когда вызываемому методу передается аргумент с неправильным значением. 
Например, `IllegalArgumentException` может генерироваться в случае, когда в качестве аргумента, указывающего количество повторов некоторого действия, передается отрицательное значение.  
Другое часто используемое исключение — `IllegalStateException`.   
Обычно оно генерируется, когда вызов является некорректным из-за состояния объекта. Например, это исключение может генерироваться, когда делается попытка использовать некий объект до его надлежащей инициализации.
```java  
    void doSomething(int index, Object obj) {  
        ...  
        if (index < 0) {  
            throw new IllegalArgumentException();   
        }  
        ...     
        if (obj == null) {  
            throw new IllegalStateException();   
        }  
        ...        
    }  
```  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 368 с.  


57. Если недостаточно информации для принятия решения и...
1) исключительная ситуация должна быть исправлена на ближайшем уровне;
2) исключительная ситуация маловероятна
Экземпляры подклассов каких типов исключений целесообразно сгенерировать в каждом случае?  
**Ответ:**  
1 – Пробросить исключение на следующий/ближайший уровень с использованием `throws`. 
В этом случае программист будет вынужден как то реагировать на исключение в месте где его 
вызывает метод его использующий и возможно уже присутствует достаточно информации, 
что бы отреагировать на него.  
2 – Попытаться организовать проверку этого редкого условия.  
**Источник:** 

58. Выделите в блоке `try-catch` основной и альтернативный сценарии.
Обоснуйте ответ.
```java 
try {
...
User user = source.getUser(login, password);
if(GUEST_USER.equals(user) {
…
} else {
…
}
...
}  catch (SourceException е) {
…
}
class Source {
public User getUser(String login, String password) throws SourceException {
...
throw new SourceException(...);
...
return GUEST_USER;	//wrong login or password
...
return new User(...);
}
...
}
```  
**Ответ:** Основным сценарием является блок `try`, альтернативным - блок `catch` который сработает при появлении исключения.  
59. Перепишите код предыдущего задания с условием, что ввод неправильных логина или пароля является альтернативным сценарием.  
**Ответ:**  
 
60. Что такое трансляция исключения, когда ее используют и какие правила ее использования? Приведите пример трансляции исключения.
**Ответ:** Верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня. Эта идиома известна как трансляция исключений (exception translation):
```java  
// Трансляция исключений  
try {  
... // Применение низкоуровневой абстракции  
} catch (LowerLevelException е) {  
    throw new HigherLevelException(...);  
}  
```  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 370 с.  

61. Как можно избежать использования трансляций и зачем нужно это предпринимать?   
**Ответ.** Этого можно добиться путем проверки корректности аргументов метода верхнего уровня перед их передачей на нижний уровень.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 372 с.

62. В каких случаях  надо предпочесть сцепление трансляции?  
**Ответ.** В тех случаях, когда исключение нижнего уровня может быть полезно для анализа ситуации, вызвавшей исключение, лучше использовать особый вид трансляции исключений, называемый цепочкой (сцеплением) исключений (exception chaining).  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 371 с.

63. Можно ли для исключительной ситуации определить, класс, который не является подклассом `Exception, RuntimeException, Error`.
    Если да, то как он будет себя проявлять (как `checked-exception` или как `unchecked-exception`)?  
**

64. Обязательно ли информацию об исключительное ситуации представлять строковым полем?
    Если нет, то какой альтернативный способ создания строкового представления исключения?

65. Если метод завершается сбоем, что нужно сделать с объектом, на котором был вызван этот метод?

66. Приведите способы достижения атомарности по отношению к сбоям.

67. Приведите пример, когда отсутствие транзакционности в исключениях, приводит к сохранению ссылки на объект в неверном состоянии.

68. Необходимо создать коллекцию из результатов тестов, находящихся в валидном файле src/in.csv.
    Пример файла
    cool;75;90
    clever;68;95
    looser;30;48
    Является ли код, реализующий задание, антипаттерном?
    Обоснуйте ответ.

public class Runner {
public static void main(String[] args) {
List<Trial> trials = new ArrayList<Trial>();
try(Scanner sc = new Scanner(new FileReader("src/in.csv"))) {
while(sc.hasNext()) {
Trial trial = getTrial(sc);
trials.add(trial);
}
printTrials(trials);
} catch (FileNotFoundException e) {
System.out.println(Constants.ERROR_FILE_FOUND);
}
}
private static Trial getTrial(Scanner sc) {
String csvLine = sc.nextLine();
String[] values = csvLine.split(Constants.DELIMETER);   	
try {
String name = values[Constants.NAME_INDEX];
int mark1 = Integer.parseInt(values[Constants.MARK1_INDEX]);
int mark2 = Integer.parseInt(values[Constants.MARK2_INDEX]);
return new Trial(name, mark1, mark2);
} catch (CsvLineException e) {
System.out.println(Constants.ERROR_WRONG_DATA);
}
}

69. Приведите пример кода собственного исключения (реализация в одном классе всего нижеперечисленного). Класс исключения содержит:
-         поле, которым является неправильная строка, считанная из файла (имя csvLine);
-         конструктор по умолчанию, вызывающий конструктор суперкласса;
-         параметризованный конструктор, принимающий экземпляр исключения и неправильную строку, считанную из файла;
-         параметризованный конструктор, принимающий строку с указанием причины исключения и  неправильную строку, считанную из файла;
-         геттер с возвратом неправильной строки;
-         переопределенного метода toString с указанием неправильной строки и метода вывода сообщения об ошибки.

70. Необходимо создать метод для экспорта csv-файла в коллекцию.
При наличии хотя бы одной ошибки в исходных данных “отменить” создание
коллекции.
Какие антипаттерны содержит следующий код?
Предложите варианты по избавлению от них.
private static List<Trial> getTrials(Scanner sc) {
List<Trial> trials = new ArrayList<Trial>();
try {
while(sc.hasNext()) {
Trial trial = getTrial(sc);
trials.add(trial);
}
} catch (CsvLineException e) {
System.err.println(e);
}
return trials;
}

72. Создать метод для экспорта данных в коллекцию из последовательного источника экземпляров Trial.
    См. код ниже.
    Его необходимо дополнить, чтобы происходила обработка следующих исключительных ситуаций:
1. 	Файл не найден.
2. 	Ошибка в csv строке.
Примечание: код не должен нарушать принцип “верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня”
См. Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 370.
Считается, что классы для исключений созданы и имеют необходимый функционал.
Подсказка:
---
Надо использовать два исключения. Одно из которых будет нижнего уровня, другое верхнего уровня.
---
Еще одна подсказка:
---
Одно из исключений обрабатываемое, другое нет.
---

//начало кода, реализующего задание
//---
interface TrialProvidable {
boolean hasTrial();
Trial getTrial();
}

public class TrialCsvImpl implements TrialProvidable {
private Scanner sc;
public CsvImpl(String csvName) {            	
sc = new Scanner(new FileReader(csvName));
}
public boolean hasTrial() {             	
return sc.hasNextLine();
}
public Trial getTrial() {
// get Trial instance from csv line
return trial;
}
}

public class Runner {
private static List<Trial> getTrials(TrialProvidable trialProvider) {
List<Trial> trials = new ArrayList<Trial>();
while(trialProvider.hasTrial()) {
Trial trial = trialProvider.getTrial();
trials.add(trial);
}
return trials;
}

public static void main(String[] args) {
TrialProvidable trialProvider = null;
try {
if("csv".equals(args[0])) {
trialProvider = new TrialCsvImpl("src/in.csv");
} else {
trialProvider = new TrialDBImpl();
}
List<Trial> trials = getTrials(trialProvider);
…
} finally {
if (trialProvider != null) {
trialProvider.close();
}
}
}
}
//---
//конец кода, реализующего задание
