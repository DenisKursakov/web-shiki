**Questions**  

1. Что такое исключения?  
**Ответ:**  Это сигнал о нестандартной – исключительной – ситуации. Ситуации могут быть самые различные – ожидаемые или нет, разной степени критичности. 
И относиться к этим ситуациям, естественно, приходится по-разному.
Как и всё в Java, исключения тоже представленны в виде классов. 
Корнем иерархии служит класс ```java.lang.Throwable```, дословно – "бросаемый". 
Его прямыми наследниками являются ```java.lang.Exception``` и ```java.lang.Error```, от которых и 
унаследованы все остальные исключения. И от которых рекомендуется наследовать собственные.  
**Источник:** http://skipy.ru/technics/exceptions.html  
   
2. Какие действия производит система времени выполнения при возникновении исключения?  
**Ответ:** После того, как метод выдает исключение, система выполнения пытается найти что-то для его обработки. Набор возможных «что-то» для обработки исключения — это упорядоченный список методов, которые были вызваны, чтобы добраться до метода, в котором произошла ошибка.  
**Источник:**  https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html  
   
3. Как называется блок кода, который обрабатывает исключение?  
**Ответ:** Система выполнения ищет в стеке вызовов метод, содержащий блок кода, способный обработать исключение. Этот блок кода называется обработчиком исключений . Поиск начинается с метода, в котором возникла ошибка, и продолжается по стеку вызовов в порядке, обратном тому, в котором были вызваны методы.   
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/definition.html  

4. Как реализуется требование «Поймай или Укажи» (Catch or Specify)?  
**Ответ:** Допустимый код языка программирования Java должен соответствовать требованиям ```Catch or Specify Requirement``` . Это означает, что код, который может вызывать определенные исключения, должен быть заключен в одно из следующих условий:
```try``` Утверждение , что перехватывает исключение. ```try``` Должен предоставить обработчик исключения, как описано в отлове и Обработка исключений .
Метод, указывающий, что он может вызвать исключение. Метод должен предоставить ```throws``` предложение, в котором перечислены исключения, как описано в разделе «Указание исключений, создаваемых методом» .
Код, который не соответствует требованиям ```Catch or Specify Requirement```, не будет компилироваться.
Не все исключения подпадают под требования «Поймать или указать».  
   Указываемое требование реализуется 2-мя путями:  
1) используя блок ```try-catch```, в котором обрабатывается исключение  
2) используя ```throws```-объявление с перечислением предполагаемых исключений  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html    
   
5. Какая иерархия классов исключений?  
**Ответ:** Все исключения являются наследниками суперкласса ```Throwable``` и его подклассов ```Error```
и ```Exception``` из пакета ```java.lang```. Исключения класса ```RuntimeException```  наследуются от класса ```Exception```.  
**Источник:**  Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 202
   
6. Какие виды исключений относятся к непроверяемым?  
**Ответ:**
В отличие от проверяемых исключений, класс ```RuntimeException``` и порожденные от него классы относятся к непроверяемым
исключениям. Компилятор не проверяет, может ли генерировать и/или обрабатывать метод эти исключения. Исключения типа ```RuntimeException``` генерируются при возникновении ошибок во время выполнения приложения.  
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 202


7. Какие компоненты могут входить в обработчик исключений?  
**Ответ:**  три компонента обработчика исключений — блоки `try, catchи finally`— для написания обработчика исключений. Затем `try`-объясняется оператор `with-resources`, представленный в `Java SE 7`. Оператор `try-with-resources` особенно подходит для ситуаций, в которых используются `Closeable` ресурсы, такие как потоки.    
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html  
   
8. Для каких ситуаций используется оператор ```try-with-resources```?  
**Ответ:** Конструкция ```try-with-resources``` дает возможность объявлять один или несколько ресурсов в блоке ```try```, которые будут закрыты автоматически без использования ```finally``` блока.
В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс ```java.lang.AutoCloseable``` или ```java.io.Closable```.
Если ```try``` блок также выбрасывает исключение, оно побеждает, а исключение из ```close()``` метода подавляется.  
**Источник:** https://www.examclouds.com/ru/java/java-core-russian/try-with-resources  
   
9. Какой код заключается в блок ```try```?
**Ответ:** Оператор или часть кода, в которой вам надо отыскать ошибку, помещается в блок ```try```.  
**Источник:** https://periscopes.ru/sozdanie-isklyuchenii-java-isklyucheniya-java.html  
   
10. Выполняется ли весь код блока ```try``` в случае возникновения исключения?  
**Ответ:**  Сначала выполняется код внутри блока ```try {...}```.  
Если в нём нет ошибок, то блок ```catch(err)``` игнорируется: выполнение доходит до конца ```try``` и потом далее, полностью пропуская ```catch```.  
Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало ```catch(err)```. Переменная ```err``` (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.  
  
11. Может ли использоваться только один блок ```try``` (без ```catch``` или ```finally```)?  
**Ответ:** У каждого раздела ```try``` должен быть по крайней мере или один раздел catch или блок ```finally```. 
Блок ```finally``` очень удобен для закрытия файлов и освобождения любых других ресурсов, захваченных для временного использования в начале выполнения метода.  
Однако операторы ```try``` можно вкладывать друг в друга. При этом если вложенный обработчик не имеет своего блока ```catch```, он осуществляет его поиск в родительском операторе. Если и там нет – блок обрабатывается системой.  
**Источник:** http://java-online.ru/java-throws.xhtml  
    
12. Какое назначение блока ```catch```?  
**Ответ:** Ближайший окружающий блок ```try``` проверяется на наличие соответствующего возбужденному исключению обработчика ```catch```. Если такой отыщется, управление передается ему. 
В блоке ```catch``` мы указываем, что за исключение надо ловить и как его обрабатывать.
Блок ```catch(){} ```похож на метод, принимающий в качестве единственного параметра ссылку на объект-исключение и обрабатывающий этот объект  
**Источник:** https://periscopes.ru/sozdanie-isklyuchenii-java-isklyucheniya-java.html  
Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 205


13. Сколько блоков ```catch``` может содержаться после ```try-оператора```?  
**Ответ:** Если в блоке ```try``` может быть сгенерировано в разных участках кода несколько типов исключений, то необходимо наличие нескольких блоков ```catch```, если только блок ```catch``` не обрабатывает все типы исключений.   
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 206  
    
14. Если применяется несколько блоков `catch`, то в каком порядке в случае возникновения исключения они вызываются?  
**Ответ:** Подклассы исключений в блоках `catch` должны следовать перед любым
из их суперклассов, иначе суперкласс будет перехватывать эти исключения.
Блоки `catch` исполняются в том порядке, в котором они указаны. Однако выполняется только `catch`, соответствующий исключению.  
Например:

```java 
try { /* код, который может вызвать исключение */
} catch(IllegalArgumentException e) {
} catch(PatternSyntaxException e) { } /* никогда не может быть вызван: ошибка компиляции */
```
где класс ```PatternSyntaxException``` представляет собой подкласс класса
```IllegalArgumentException```.  
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 206-207  

15. Какой код может быть между блоками `try` и `catch`?  
**Ответ:** Предположим , что это допустимо Java (это не компилирует):
```java 
try {
throw new Exception();
}
System.out.println("Sup!");
catch(Exception e) { }
```
Когда возникает исключение, строка, которая выводит `Sup!` , все равно будет пропущена, поскольку 
```JVM``` ищет, чтобы перейти к соответствующему обработчику исключений для обработки ```Exception``` . 
Таким образом, в некотором смысле код ведет себя так же, как если бы он находился в самом блоке t```ry {}```, 
поэтому на самом деле не имеет значения, где он находится, и Java указывает, что эта ( теперь доказанная бесполезность ) 
конструкция является незаконной. Исходя из примера становится понятно что между блоками `try` и `catch` не может быть кода.  


16. Может ли использоваться блок ```catch``` без блока ```try```?   
**Ответ:** Невозможно иметь блок ```catch``` без ```try```. Блок ```try``` передает ошибку блоку ```catch``` 
соответственно если блок ```try``` отсутствует то блоку ```catch``` исключение передано не будет, в таком случае его наличие бессмысленно.  


17. Сколько типов исключений может обрабатывать один блок ```catch```?  
**Ответ:** ```Multi-catch``` блок может содержать только исключения не входящие в одну иерархию. 
Один ```catch``` блок может обрабатывать несколько типов исключений прописанных через '|' в параметрах блока, так же обрабатывая наследников указанных исключений.  

18. В случае отсутствия исключения в блоке ```try``` выполняется ли блок ```catch```?  
**Ответ:** Нет, т.к. блок ```try``` передает исключение в блок ```catch``` соответственно при остутсвии исключения блок ```catch``` не будет запущен.  

19. Для чего используется блок ```finally```?  
**Ответ:** Блок ```finally``` идет в самом конце конструкции ```try/catch/finally```.
Возможна ситуация, при которой нужно выполнить некоторые действия
по завершению программы (закрыть поток, освободить соединение с базой
данных) вне зависимости от того, произошло исключение или нет. В этом
случае используется блок ```finally```, который обязательно выполняется после инструкций ```try``` или ```catch```.   
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 211  


20. В случае отсутствия исключения в блоке `try` выполняется ли блок `finally` (при его наличии)?  
**Ответ:** Ключевая особенность блока ```finally``` заключается в том, 
что он выполняется обязательно после инструкций ```try``` или ```catch.```, вне зависимости от того, сработал ```catch``` или нет.   
**Источник:** http://skipy.ru/technics/exceptions.html#rex  
    
21. Могут ли использоваться блоки `try-finally `без блока `catch`?  
**Ответ:** Да. Ключевое слово ``finally`` создаёт блок кода, который будет выполнен после завершения блока 
``try/catch``, но перед кодом, следующим за ним. Блок будет выполнен, независимо от того, 
передано исключение или нет. Оператор ``finally`` не обязателен, однако каждый оператор ``try`` требует 
наличия либо ``catch``, либо ``finally``.  
**Источник:** http://developer.alexanderklimov.ru/android/java/exception.php  

22. Приведите пример кода, в котором используется оператор `try-with-resources`.  
**Ответ:**  
В следующем примере считывается первая строка из файла. Он использует экземпляр `BufferedReader` для 
чтения данных из файла. ``BufferedReader``- это ресурс, который необходимо закрыть после того, 
как программа завершит работу с ним:
```java 

static String readFirstLineFromFile (String path) выдает исключение IOException {
     try (BufferedReader br =
                   new BufferedReader (новый FileReader (путь))) {
        вернуть br.readLine ();
    }
}
```
В этом примере ресурс, объявленный в `try` операторе `-with-resources`, является файлом `BufferedReader`. 
Оператор объявления появляется в круглых скобках сразу после `try` ключевого слова.
Поскольку `BufferedReader` экземпляр объявлен в операторе `try-with-resource`, он будет закрыт независимо от того, 
`try` завершается ли оператор нормально или внезапно (в результате того, что метод `BufferedReader.readLine` выбрасывает `IOException`).  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  

23. Какой оператор может использоваться вместо `try-with-resources`?  
**Ответ:** До `Java SE 7` можно было использовать `finally` блок, чтобы гарантировать, что ресурс закрыт, независимо от того, `try` завершается ли оператор нормально или внезапно.  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  
    
24. Может ли применяться оператор `try-with-resources` совместно с блоком `finally`?  
**Ответ:**
Оператор `try-with-resources` может иметь `catch и finally` блоки, как обычный `try` оператор.
В операторе `try-with-resources` любой блок `catch` or `finally` запускается после закрытия объявленных ресурсов.  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  
    
25. Какое ключевое слово используется в сигнатуре метода, чтобы указать на возможность выбрасывания им исключения?  
**Ответ:**  Когда вы не планируете обрабатывать исключение в своем методе, но хотите предупредить 
пользователей метода о возможных исключительных ситуациях — используйте ключевое слово `throws`. Это ключевое слово в сигнатуре метода означает, что при определенных условиях метод, может выбросить исключение  
**Источник:** https://javarush.ru/groups/posts/isklyucheniya-java  
    
26. Сколько исключений может выбрасывать метод?  
**Ответ:** Нет никаких ограничений относительно того, сколько исключений может быть вызвано методом.  
**Источник:** 

27. Какое ключевое слово используется для гарантированного выбрасывания исключения?  
**Ответ:** Все методы используют оператор `throw` для создания(выбрасывания) исключения. Для `throw` 
утверждения требуется единственный аргумент: метательный объект. Метательные объекты - это экземпляры любого подкласса `Throwable` класса. Вот пример `throw` утверждения.  
```java 
throw someThrowableObject ;
```  
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/throwing.html  

28. Можно ли создавать свои собственные классы исключений?  
**Ответ:** Да, более того во многих ситуациях рекомендуется создание собственного исключения.
Для повышения качества и скорости восприятия кода разработчик может создать собственное исключение как подкласс класса `Exception` и затем
использовать его при обработке ситуации, не являющейся исключением с точки зрения языка, но нарушающей логику вещей. По соглашению наcледник
любого класса-исключения должен заканчиваться словом `Exception`.  
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 212  
    
29. Приведите примеры наиболее известных подклассов класса `Exception`.  
**Ответ:** 
```java 
IOException - исключения ввода-вывода;
IllegalAccessException - запрещен доступ к классу;
ClassNotFoundException -  класс не найден;
RuntimeException - исключения, которые могут быть предотвращены программно;
NoSuchFieldException - запрашиваемое поле не существует;
NoSuchMethodException - запрашиваемый метод не существует;
```
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 203  


30. Приведите примеры наиболее известных подклассов класса `RuntimeException`.  
**Ответ:** 
```java 
ArithmeticException - Арифметическая ошибка: деление на ноль и др.  
ArrayIndexOutOfBoundsException - Индекс массива находится вне его границ  
ArrayStoreException - Назначение элементу массива несовместимого типа  
ClassCastException - Недопустимое приведение типов  
ConcurrentModificationException - Некорректный способ модификации коллекции  
IllegalArgumentException - При вызове метода использован некорректный аргумент  
IllegalMonitorStateException - Незаконная операция монитора на разблокированном   
объекте  
IllegalStateException - Среда или приложение находятся в некорректном   
состоянии  
IllegalThreadStateException - Требуемая операция не совместима с текущим   
состоянием потока  
IndexOutOfBoundsException - Некоторый тип индекса находится вне границ коллекции  
NegativeArraySizeException - Попытка создания массива с отрицательным размером  
NullPointerException - Недопустимое использование  ссылки  на null  
NumberFormatException - Невозможное преобразование строки в числовой формат  
StringIndexOutOfBoundsException - Попытка индексации вне границ строки  
MissingResourceException - Отсутствие файла ресурсов properties или имени   
ресурса в нем  
EnumConstantNotPresentException - Несуществующий элемент перечисления  
UnsupportedOperationException - Встретилась неподдерживаемая операция  
```
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 204  

31. Что такое сцепление исключений?  
**Ответ:** В тех случаях, когда исключение нижнего уровня может быть полезно при анализе ситуации,
вызвавшей исключение, лучше использовать особый вид трансляции исключений, называемый
сцеплением исключении (exception chaining). При этом исключение нижнего уровня передается с
исключением верхнего уровня; в последнем создается открытый метод доступа, позволяющий извлечь
исключение нижнего уровня  
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 168.  

32. Приведите пример кода со сцеплением исключений.  
**Ответ:** 
```java 
try { 
// Использование абстракции нижнего уровня 
// для выполнения наших указаний 
} catch(LowerLevelException е) { 
throw new H1gherLevelException(e); 
}
```
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 168.  

33. Какая информация приводится при трассировке стека во время исключения?  
**Ответ:** Если выполнение программы завершается аварийно из-за необработанного исключения, система
автоматически распечатывает трассировку стека для этого исключения. Трассировка стека содержит
строковое представление данного исключения, результат вызова его метода `toString`.  
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 171.  

34. В каких случаях целесообразно создавать собственный класс исключения?  
**Ответ:** Для повышения качества и скорости восприятия кода разработчик может создать собственное исключение как подкласс класса `Exception` и затем
использовать его при обработке ситуации, не являющейся исключением с точки зрения языка, но нарушающей логику вещей.  
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 212  

35. Какой класс исключений может использоваться в качестве суперкласса для собственного исключения?  
**Ответ:** Класс `Exception` и его потомки могут использоваться в качестве супперкласса для собственных исключений.   
**Источник:** Блинов,И.Н., Романчик, В.С. Java. Методы программирования : уч.-мет. пособие / И.Н. Блинов, В.С. Романчик. стр. 212  

36. Какие исключения целесообразно делать проверяемыми, а какие – непроверяемыми?  
**Ответ:** Исключения-наследника от класса `Exception` целесообразно делать проверяемыми,
от `RuntimeException` - непроверяемыми. 
**Источник:** http://www.quizful.net/post/java-exceptions  

37. Какие преимущества в механизме выбрасывания и обработки исключений?   
**Ответ:**  
а) Разделение кода обработки ошибок от основного кода программы.  
б) Возможностью распространить сообщение об ошибке в стеке вызовов методов.  
в) Группировка и дифференциация типов исключений   
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/advantages.html    

38. Можно ли выбрасывать исключения в конструкторах?  
**Ответ:** Для конструкторов - да: вы должны генерировать исключение из конструктора всякий раз, когда вы не можете должным образом инициализировать (построить) объект.  
**Источник:** https://isocpp.org/wiki/faq/exceptions#ctors-can-throw  

39. Может ли произойти потеря исключения? Если да – приведите пример.  
**Ответ:**   Блок ``finally`` может вызвать потерю исключений. Пример:  
```java 
import java.io.IOException;

/**
 * ExceptionLossTest
 */
public class ExceptionLossTest{

    public static void main(String[] args){
        try {
            try {
                throw new Exception("a");
            } finally {
                if (true) {
                    throw new IOException("b");
                }
                System.err.println("c");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("d");
            System.err.println(ex.getMessage());
        }
    }
}
```  
После инициации первого исключения – `new Exception("a")` – будет выполнен блок `finally`, в котором будет брошено исключение new ```IOException("b")```. И именно это исключение будет поймано и обработано. Исходное же исключение теряется.  
**Источник:** http://www.skipy.ru/technics/exceptions.html   

40. Обладают ли исключения свойством транзакционности?  
**Ответ:** Cвойством транзакционности исключения не обладают – действия, произведенные в блоке `try` до возникновения исключения, не отменяются поcле его возникновения.  
**Источник:** http://www.skipy.ru/technics/exceptions.html#no_trans  

41. Является ли данный код антипаттерном?  
    Обоснуйте ответ.
```java
void methodCatchesSomeException() {
...
try {
...
} catch (SomeException ex) {
...
}
...
}
```
**Ответ:** Нет, блок `try` и `catch` объявлены в методе верно, исключение (при его наличии) будет перехвачено.  

42. Является ли данный код антипаттерном?
Обоснуйте ответ.
```java 
void methodThrowsSomeCheckedException() {
...
throw new SomeCheckedException();
...
}
```  
**Ответ:** Да, у данного метода отсутствует объявление исключения в секции `throws` и передача вызывающему методу.   

43. Является ли данный код верным? Укажите почему.
```java 
void methodThrowsSomeCheckedException() throws SomeCheckedException {
...
throw new SomeCheckedException();
...
}
```   
**Ответ:** Код является верным т.к., в теле метода прописана генерация исключения которое в секции `throws` передает исключение вызывающему методу.  

44. Приведите примеры кода с выбросом `RuntimeException` явным образом и в случае программной ошибки.  
**Ответ:** 
```java 
public class RuntimeChecker {   
// явным образом  
    void methodThrowsSomeRuntimeException() {  
        throw new ArrayIndexOutOfBoundsException;
    }  
// в случае программной ошибки  
    void methodWithSomeRuntimeException() {  
        String[] someArray = new String[5];  
        String elementsWithTenId = someArray[10]; // result - ArrayIndexOutOfBoundsException   
    }  
}
```

45. Можно ли отрефакторить данный код? Если да, то выполните.  
```java 
void methodThrowsSomeRuntimeException() {
...
throw new SomeRuntimeException();
...
}
```  
**Ответ:** Можно добавить информацию об ошибке при генерации исключения `SomeRuntimeException()`.  

46. Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java 
void methodThrowsSomeRuntimeException() throws SomeRuntimeException {
...
throw new SomeRuntimeException();
...
}
```  
**Ответ.** Да, данный код - антипаттерн. Для исключений-подклассов класса RuntimeException (unchecked) 
используемых для отображения программных ошибок, при выполнении приложения в объявлении 
метода секция throws может отсутствовать, так как играет только информационную роль.   
**Источник.** Java from EPAM : учеб.-метод. пособие / И. Н. Блинов, В. С. Романчик, 2020. – 276 с.  


47. В какой версии ``Java`` появился оператор ``try-with-resources``? Приведите пример кода с использованием указанного оператора.  
**Ответ:** Конструкцию `try-with-resources` ввели в `Java 7`. Пример: 
```java 
static String readFirstLineFromFile(String path) throws IOException {
    try (BufferedReader br =
                   new BufferedReader(new FileReader(path))) {
        return br.readLine();
    }
}
```
**Источник:** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  

48. Является ли данный код антипаттерном?
Обоснуйте ответ.
```java 
void methodWithAutocloseableInstance() {
...
try(SomeResource res = new SomeResource(...)) {
...
}
...
}
```
**Ответ:** Да. В данном коде отсутсвуют блоки `catch` и `finally`. Блок `try` обязательно должен иметь блок `catch` или `finally`.  

49. Является ли данный код антипаттерном?
Обоснуйте ответ.
```java 
void methodWithAutocloseableInstance() {
...
try(SomeResource res = new SomeResource(...)) {
...
} catch (CorrectCheckedException ex) {
…
}
...
}
```  
**Ответ:** Нет, код корректный. Используется `try-with-resources` соответственно все ресурсы будут зыкрыты, 
блок `catch` для обработает исключения.  

50. Является ли данный код антипаттерном?  
Обоснуйте ответ.  
```java 
try {
…
}  catch (SomeException е) {
//no code
}
```  
**Ответ:** Пустой блок `catch` лишает исключение смысла, который состоит в том, чтобы вы
обрабатывали исключительную ситуацию. Блок `catch` обязан содержать, по крайней мере,
комментарий, объясняющий, почему данное исклю чение следует игнорировать.  
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 175.  

51. Является ли данный код антипаттерном?  
Обоснуйте ответ.
```java 
try {
…
}  catch (SomeException е) {
System.out.println(“Something went wrong!”);
}
``` 
Это вариант предыдущего антипаттерна.  
В данном случае проблема “решается” тем, что о ней сообщается, но вычислительный процесс такое “решение” не восстанавливает.  
**Источник:**  Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 379.  

52. Является ли данный код антипаттерном, если блок `catch` находится не в конце раннер-метода `main()`?  
Обоснуйте ответ.
```java 
try {
…
}  catch (Exception е) {
…
}
…

или другой вариант

try {
…
}  catch (Throwable е) {
…
}
…
```  
**Ответ:** Нет, блок `catch` может находиться не в конце раннер-метода `main()`. 
Однако не используйте `Exception, RuntimeException, Throwable и Error` непосредственно. Рассматривайте эти классы как если бы они были абстрактными. Нельзя надежно протестировать эти исключения, поскольку они являются суперклассами для других исключений, которые может генерировать метод.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 368 с.  

53. Является ли данный код антипаттерном?  
Обоснуйте ответ.
```java 
try {
int i = 0;
while(true) {
а[i++].f();
}
} catch(ArraylndexOutOfBoundsException е) {
…
}
```  
**Ответ:** `ArrayIndexOutOfBoundsException` - относится к `RuntimeException` такого типа исключения нельзя перехватывать, т.к. в большинстве случаев это ошибка программирования, и подобным образом она скрывается.  

54. Есть ли недостатки у `API` написанного только с использованием обрабатываемых исключений?  
**Ответ:** 
Такое решение оправданно, если даже при надлежащем применении интерфейса `API` невозможно
предотвратить возникновение условий для исключительной ситуации, однако программист,
пользующийся данным `API`, столкнувшись с этим исключением, мог бы предпринять какие-либо
полезные действия. Если не выполняются оба этих условия, лучше пользоваться необрабатываемым
исключением.  
**Источник:** Java TM Эффективное программирование Джошуа Блох стр. 163.  

55. Даны два варианта сеттера.
Какой является более предпочтительным в использовании?  
Обоснуйте ответ.
```java 
Вариант 1.
void setPositiveValue(int value) {
if(value <= 0) {
throw new IllegalArgumentException(...);
}
this.value = value;
}
Вариант 2.
void setPositiveValue(int value) throws SomeCheckedException {
if(value <= 0) {
throw new SomeCheckedException(...);
}
this.value = value;
}
```
**Ответ.** Вариант 1.  
Повторное использование имеющихся исключений имеет ряд преимуществ.   
Главное среди них то, что они упрощают изучение и применение ваших `API`, поскольку соответствуют установленным соглашениям, с которыми хорошо знакомы программисты. 
С этим же связано второе преимущество, заключающееся в том, что программы, использующие ваш `API`, проще для чтения и понимания, поскольку в них нет незнакомых, сбивающих с толку исключений. 
Наконец, чем меньше классов исключений, тем меньше требуется места в памяти и времени на их загрузку.    
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 367 с.

56. Приведите пример наиболее распространенных из повторно используемых исключений и причины их применения.  
**Ответ:**  
1)``IllegalArgumentException`` - Неверное ненулевое значение параметра  
2)``IllegalStateException`` - Неверное состояние объекта для вызова метода  
3)``NullPointerException`` - Неразрешенное нулевое значение параметра  
4)``IndexOutOfBoundsException`` - Индексный параметр за границей допустимого диапазона  
5)``ConcurrentModificationException`` - Обнаружено запрещенное параллельное изменение объекта  
6)``UnsupportedOperationException`` - Объект не поддерживает метод  
**Источник:** Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 369.  


57. Если недостаточно информации для принятия решения и...
1) исключительная ситуация должна быть исправлена на ближайшем уровне;
2) исключительная ситуация маловероятна
Экземпляры подклассов каких типов исключений целесообразно сгенерировать в каждом случае?  
**Ответ:**  
1) Экземпляры подклассов `Exception`  
2) Экземпляры подклассов `RuntimeException`  
**Источник:**  Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 363.  

58. Выделите в блоке `try-catch` основной и альтернативный сценарии.
Обоснуйте ответ.
```java 
try {
...
User user = source.getUser(login, password);
if(GUEST_USER.equals(user) {
…
} else {
…
}
...
}  catch (SourceException е) {
…
}
class Source {
public User getUser(String login, String password) throws SourceException {
...
throw new SourceException(...);
...
return GUEST_USER;	//wrong login or password
...
return new User(...);
}
...
}
```  
**Ответ:** Основным сценарием является блок `try`, альтернативным - блок `catch` который сработает при появлении исключения.  

59. Перепишите код предыдущего задания с условием, что ввод неправильных логина или пароля является альтернативным сценарием.  
**Ответ:**  
```java  
        User user = source.getUser(login, password);  
        if (GUEST_USER.equals(user)) {  
                    …  
        } else {  
                    …  
        }  
class Source {  
    public User getUser(String login, String password) {  
                ...  
        return GUEST_USER; // wrong login or password  
                ...  
        return new User();  
    }  
    ...  
}  
```  

60. Что такое трансляция исключения, когда ее используют и какие правила ее использования? Приведите пример трансляции исключения.
**Ответ:** Верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня. Эта идиома известна как трансляция исключений (exception translation):
```java  
// Трансляция исключений  
try {  
... // Применение низкоуровневой абстракции  
} catch (LowerLevelException е) {  
    throw new HigherLevelException(...);  
}  
```  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 370 с.  

61. Как можно избежать использования трансляций и зачем нужно это предпринимать?    
**Ответ.** Этого можно добиться путем проверки корректности аргументов метода верхнего уровня перед их передачей на нижний уровень.  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 372 с.  

62. В каких случаях  надо предпочесть сцепление трансляции?    
**Ответ.** В тех случаях, когда исключение нижнего уровня может быть полезно для анализа ситуации, вызвавшей исключение, лучше использовать особый вид трансляции исключений, называемый цепочкой (сцеплением) исключений (exception chaining).  
**Источник.** Java: эффективное программирование, 3-е изд. : Блох, Джошуа 2019. – 371 с.  

63. Можно ли для исключительной ситуации определить, класс, который не является подклассом `Exception, RuntimeException, Error`.
    Если да, то как он будет себя проявлять (как `checked-exception` или как `unchecked-exception`)?    
**Ответ:** Для исключительной ситуации можно определить класс, который не наследует классов `Exception,
RuntimeException и Error`. В спецификации· языка `Java` такие классы напрямую не оговариваются, однако
неявно подразумевается, что они будут вести себя так же, как обычные обрабатываемые исключения
(которые являются подклассами класса `Exception`, но не `RuntimeException`).Однако, желательно не использовать такой класс. Не имея никаких преимуществ перед обычным
    проверяемым исключением, он будет только запутывать пользователей вашего API.    
**Источник.** Java: эффективное программирование : Блох, Джошуа – 162 с.  

64. Обязательно ли информацию об исключительное ситуации представлять строковым полем?  
    Если нет, то какой альтернативный способ создания строкового представления исключения?    
**Ответ:** Один из приемов, гарантирующих, что строковое представление исключения будет содержать
информацию, достаточную для Описания сбоя, состоит в том, чтобы эта информация запрашивалась
в конструкторах исключения, а в строке описания. Само же описание исключения можно затем
генерировать автоматически для представления этой информации. Например, вместо конструктора
`String` исключение `IndexOutOfBounds` могло бы иметь следующий конструктор:  
```java 
Public IndexOutOfBoundsExoeption(int lowerBound, int index) { 
// Генерируем описание исключения, 
// фиксирующее обстоятельства отказа 
super( "Lower bound: " + lowerBound + 
“,Upper bound: " + uppe rBound + 
“,Index: " + index); 
} 
```
**Источник:** Java: эффективное программирование : Блох, Джошуа – 172 с.  

65. Если метод завершается сбоем, что нужно сделать с объектом, на котором был вызван этот метод?    
**Ответ:** Крайне важно, чтобы
метод `toString` в классе исключения возвращал как можно больше информации о причинах отказа.
Иными словами, строковое представление исключения должно зафиксировать отказ для
последующего анализа. Для фиксации сбоя строковое представление исключения должно содержать значения всех
параметров и полей, "способствовавших появлению этого исключения".
**Источник:** Java: эффективное программирование : Блох, Джошуа – 171 - 172 с.  

66. Приведите способы достижения атомарности по отношению к сбоям.  
**Ответ:** Добиться такого эффекта можно несколькими способами.  
а) Простейший способ заключается в
создании неизменяемых объектов . Если объект неизменяемый, получение атомарности не
требует усилий. Если операция заканчивается сбоем, это может помешать созданию нового объекта,
но никогда не оставит уже имеющийся объект в неопределенном состоянии, поскольку состояние
каждого неизменяемого объекта согласуется в момент его создания и после этого уже не меняется.  
б) Другой прием, который тесно связан с предыдущим и позволяет добиться атомарности по
отношению к сбоям, заключается в упорядочении вычислений таким образом, чтобы все фрагменты
кода, способные повлечь сбой, предшествовали первому фрагменту, который модифицирует объект.
Такой прием является естественным расширением предыдущего в случаях, когда невозможно
произвести проверку аргументов, не выполнив хотя бы части вычислений.  
в) Третий, редко встречающийся прием, заключается в написании специального кода восстановления
(recovery code), который перехватывает сбой, возникающий в ходе выполнения операции, и заставляет
объект вернуться в то состояние, в котором он находился в момент, предшествующей началу
операции.  
г) Наконец, последний прием, позволяющий добиться атомарности метода, заключается в том,
чтобы выполнять операцию на временной копии объекта, и как только операция будет завершена,
замещать содержимое объекта содержимым его временной копии.  
**Источник:** Java: эффективное программирование : Блох, Джошуа – 173 - 174 с.  

67. Приведите пример, когда отсутствие транзакционности в исключениях, приводит к сохранению ссылки на объект в неверном состоянии.  
**Ответ:**  
```java 
package test;

/**
 * PartialInitTest
 *
 * @author Eugene Matyushkin
 */
public class PartialInitTest{

    static PartialInitTest self;

    private int field1 = 0;
    private int field2 = 0;

    public PartialInitTest(boolean fail) throws Exception{
        self = this;
        field1 = 1;
        if (fail) {
            throw new Exception();
        }
        field2 = 1;
    }

    public boolean isConsistent(){
        return field1 == field2;
    }

    public static void main(String[] args){
        PartialInitTest pit = null;
        try {
            pit = new PartialInitTest(true);
        } catch (Exception ex){
            // do nothing
        }
        System.out.println("pit: "+pit);
        System.out.println("PartialInitTest.self reference: "+PartialInitTest.self);
        System.out.println("PartialInitTest.self.isConsistent(): "+PartialInitTest.self.isConsistent());
    }
}
``` 
В конструкторе мы присваиваем ссылку на созданный объект статической переменной. Дальше мы инициализируем одно поле и... бросаем исключение.  
В методе `main` это исключение обрабатывается. Однако ссылка на объект – существует! В чем можно убедиться, выполнив приведенный код:  
```java 
pit: null
PartialInitTest.self reference: test.PartialInitTest@1e0bc08
PartialInitTest.self.isConsistent(): false
```  
Переменная метода main равна ``null``, как и положено. А вот статическая переменная `self` – нет. Через нее можно получить доступ к объекту, инициализация которого была прервана исключением. И объект этот, естественно, в неверном состоянии. Вот она – утечка памяти. 
Объект не будет удален до тех пор, пока на него есть ссылка.  
**Источник:** http://skipy.ru/technics/exceptions.html#no_trans  

68. Необходимо создать коллекцию из результатов тестов, находящихся в валидном файле `src/in.csv`.
Пример файла  
`
cool;75;90
clever;68;95
looser;30;48
`
Является ли код, реализующий задание, антипаттерном?  
Обоснуйте ответ.  
```java 
public class Runner {
public static void main(String[] args) {
List<Trial> trials = new ArrayList<Trial>();
try(Scanner sc = new Scanner(new FileReader("src/in.csv"))) {
while(sc.hasNext()) {
Trial trial = getTrial(sc);
trials.add(trial);
}
printTrials(trials);
} catch (FileNotFoundException e) {
System.out.println(Constants.ERROR_FILE_FOUND);
}
}
private static Trial getTrial(Scanner sc) {
String csvLine = sc.nextLine();
String[] values = csvLine.split(Constants.SEMICOLON);   	
try {
String name = values[Constants.NAME_INDEX];
int mark1 = Integer.parseInt(values[Constants.MARK1_IND]);
int mark2 = Integer.parseInt(values[Constants.MARK2_IND]);
return new Trial(name, mark1, mark2);
} catch (CsvLineException e) {
System.out.println(Constants.WRONG_DATA);
}
}
```  
**Ответ:** Данный код является антипаттерном т.к. исключение перехватывается внутри метода и такой перхват будет игнорировать ошибку.   
В случае ошибки в методе `getTrial` метод не будет ничего возвращать. Т.к. в блоке `catch` не прописан альтернативный сценарий для возвращения элемента.    

69. Приведите пример кода собственного исключения (реализация в одном классе всего нижеперечисленного). Класс исключения содержит:  
- поле, которым является неправильная строка, считанная из файла (имя csvLine);  
- конструктор по умолчанию, вызывающий конструктор суперкласса;  
- параметризованный конструктор, принимающий экземпляр исключения и неправильную строку, считанную из файла;  
- параметризованный конструктор, принимающий строку с указанием причины исключения и  неправильную строку, считанную из файла;  
- геттер с возвратом неправильной строки;  
- переопределенного метода toString с указанием неправильной строки и метода вывода сообщения об ошибки.  
**Ответ:**  
```java 
public class SomeCsvLineException extends Exception {
    private String wrongCsvLine;

    public SomeCsvLineException() {
        super();
    }

    public SomeCsvLineException(String message, String wrongCsvLine) {
        super(message);
        this.wrongCsvLine = wrongCsvLine;
    }

    public SomeCsvLineException(Throwable cause, String wrongCsvLine) {
        super(cause);
        this.wrongCsvLine = wrongCsvLine;
    }

    public String getWrongCsvLine() {
        return wrongCsvLine;
    }

    @Override
    public String toString() {
        return wrongCsvLine + super.toString();
    }
}
```

70. Необходимо создать метод для экспорта csv-файла в коллекцию.   
При наличии хотя бы одной ошибки в исходных данных “отменить” создание  
коллекции.  
Какие антипаттерны содержит следующий код?  
Предложите варианты по избавлению от них.  
```java 
private static List<Trial> getTrials(Scanner sc) {
List<Trial> trials = new ArrayList<Trial>();
try {
while(sc.hasNext()) {
Trial trial = getTrial(sc);
trials.add(trial);
}
} catch (CsvLineException e) {
System.err.println(e);
}
return trials;
}
```
**Ответ:**
Если во время цикла случится сбой, колекция, наполненная экземплярами класса `Trial` по прежнему будет существовать.    
Таким образом метод вернет не пустую коллекцию а частично заполненную, чтоб избежать этого в блоке `catch` коллекции стоит присвоить новую (пустую) коллекцию которая после будет возвращена методом.  

71. Создать метод для экспорта данных в коллекцию из последовательного источника экземпляров `Trial`.
См. код ниже.
Его необходимо дополнить, чтобы происходила обработка следующих исключительных ситуаций:
Файл не найден.
Ошибка в csv строке.
Примечание: код не должен нарушать принцип “верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня”
См. Блох, Д. Java эффективное программирование. 3-е издание. Глава 10 Исключения. Стр 370.
Считается, что классы для исключений созданы и имеют необходимый функционал.
Подсказка:
---
Надо использовать два исключения. Одно из которых будет нижнего уровня, другое верхнего уровня.
---
Еще одна подсказка:
---
Одно из исключений обрабатываемое, другое нет.
---

```java 
//начало кода, реализующего задание
//---
interface TrialProvidable {
boolean hasTrial();
Trial getTrial();
}

public class TrialCsvImpl implements TrialProvidable {
private Scanner sc;
public CsvImpl(String csvName) {            	
sc = new Scanner(new FileReader(csvName));
}
public boolean hasTrial() {             	
return sc.hasNextLine();
}
public Trial getTrial() {
// get Trial instance from csv line
return trial;
}
}

public class Runner {
private static List<Trial> getTrials(TrialProvidable trialProvider) {
List<Trial> trials = new ArrayList<Trial>();
while(trialProvider.hasTrial()) {
Trial trial = trialProvider.getTrial();
trials.add(trial);
}
return trials;
}

public static void main(String[] args) {
TrialProvidable trialProvider = null;
try {
if("csv".equals(args[0])) {
trialProvider = new TrialCsvImpl("src/in.csv");
} else {
trialProvider = new TrialDBImpl();
}
List<Trial> trials = getTrials(trialProvider);
…
} finally {
if (trialProvider != null) {
trialProvider.close();
}
}
}
}
//---
//конец кода, реализующего задание
```  
**Ответ:** 
```java  
  public interface TrialProvidable {  
boolean hasTrial();  
Trial getTrial() throws CsvLineException;  
void close();  
}
public class TrialCsvImpl implements TrialProvidable {  
private Scanner sc;
    public TrialCsvImpl(String csvName) {  
        try {  
            sc = new Scanner(new FileReader(csvName));  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        }  
    }  
  
    @Override  
    public boolean hasTrial() {  
        return sc.hasNextLine();  
    }  
  
    @Override  
    public Trial getTrial() throws CsvLineException {  
        Trial trial = null;  
        String line = sc.nextLine();  
        try {  
            String name = sc.next();  
            int age = (int) Integer.parseInt(sc.next());  
            trial = new Trial(name, age);  
        } catch (NumberFormatException e) {  
            throw new CsvLineException(e.getMessage(), line);  
        }  
        return trial;  
    }  
  
    @Override  
    public void close() {  
        sc.close();      
    }  
}
public class Runner {
    private static List<Trial> getTrials(TrialProvidable trialProvider) {  
        List<Trial> trials = new ArrayList<Trial>();  
        while (trialProvider.hasTrial()) {  
            Trial trial = null;  
            try {  
                trial = trialProvider.getTrial();  
            } catch (CsvLineException e) {  
                e.printStackTrace();  
            }  
            if (trial != null) {  
                trials.add(trial);  
            }  
        }  
        return trials;  
    }  
  
    public static void main(String[] args) {  
        TrialProvidable trialProvider = null;  
        try {  
            if ("csv".equals(args[0])) {  
                trialProvider = new TrialCsvImpl("src/in.csv");  
            } else {  
                trialProvider = new TrialDBImpl();  
            }  
            List<Trial> trials = getTrials(trialProvider);  
//          ...  
} finally {  
if (trialProvider != null) {  
trialProvider.close();  
}  
}  
}  
}
```  

