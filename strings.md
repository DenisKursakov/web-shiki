**Theory**  

**Questions**  

Вопрос 1.  
Что появится в консоли в результате работы фрагмента программы?
```java 
String a = "java";
a.toUpperCase();
System.out.println(a);
```
**Ответ:** Метод ```toUpperCase()``` поднимает все символы строки в верхний регистр. Однако т.к. класс ```String``` 
неизменяемый этот метод не поменяет переменную ```a```. Для ее изменения следует прописать ```a = a.toUpperCase()```.
Вывод в консоль будет следующим: 
```java```

Вопрос 2.  
Что появится в консоли в результате работы фрагмента программы?
```java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");
System.out.println("s1 == s2 : " + (s1 == s2));
System.out.println("s1 == s3 : " + (s1 == s3));
System.out.println(s1.equals(s3));
```
Поясните ответ.  
**Ответ:**  
При создании экземпляра класса String путем присваивания его ссылки
на литерал, последний помещается в так называемый «пул литералов». Если
в дальнейшем будет создана еще одна ссылка на литерал, эквивалентный ранее
объявленному, то будет произведена попытка добавления его в «пул литералов». Так как идентичный литерал там уже существует, то дубликат не может
быть размещен, и вторая ссылка будет на существующий литерал, такой принцип отслеживается при создании строки ```s2```. 
При сравнении строк через оператор ```==``` сравниваются их ссылки и в первом случае ```s1``` имеет ту же ссылку что и ```s2```.
Однако ```s3``` имеет другую ссылку. 
При сравнении строк через метод ```equals()``` сравниваются значения. Соответственно вывод будет следующим:
```java 
s1 == s2 : true 
s1 == s3 : false
true
```
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 173-174  

Вопрос 3.  
Можно ли выполнить наследование от класса String?
Почему?  
**Ответ:** Нет, т.к. класс ```String``` является финальным (неизменным) классом.  
**Источник:** https://docs.oracle.com/javase/tutorial/java/data/strings.html

Вопрос 4.
Назовите основные, на ваш взгляд, методы класса String.  
**Ответ:** 
```java 
String s = "Hello, EPAM!"
String concat(String s) или «+» — слияние строк;
boolean equals(Object ob) и equalsIgnoreCase(String s) — сравнение строк 
с учетом и без учета регистра соответственно;
int compareTo(String s) и compareToIgnoreCase(String s) — лексикографи-
ческое сравнение строк с учетом и без учета их регистра. Метод осуществляет 
вычитание кодов первых различных символов вызывающей и передаваемой 
строки в метод строк и возвращает целое значение. Метод возвращает значе-
ние нуль в случае, когда equals() возвращает значение true;
boolean contentEquals(StringBuffer ob) — сравнение строки и содержимо-
го объекта типа StringBuffer;
String substring(int n, int m) — извлечение из строки подстроки длины 
m-n, начиная с позиции n. Нумерация символов в строке начинается с нуля;
String substring(int n) — извлечение из строки подстроки, начиная с позиции n;
int length()— определение длины строки;
int indexOf(char ch)— определение позиции символа в строке;
static String valueOf(значение) — преобразование переменной базового 
типа к строке;
String toUpperCase()/toLowerCase()— преобразование всех символов вы-
зывающей строки в верхний/нижний регистр;
String replace(char с1, char с2) — замена в строке всех вхождений первого 
символа вторым символом;
String intern() — заносит строку в «пул» литералов и возвращает ее объект-
ную ссылку;
String trim() — удаление всех пробелов в начале и конце строки;
char charAt(int position) — возвращение символа из указанной позиции 
(нумерация с нуля);
boolean isEmpty() — возвращает true, если длина строки равна 0;
char[] getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) — извле-
чение символов строки в массив символов;
static String format(String format, Object… args), format(Locale l, String
format, Object… args)— генерирует форматированную строку, полученную 
с использованием формата, интернационализации и др.;
String[] split(String regex), String[] split(String regex, int limit) — поиск 
вхождения в строку заданного регулярного выражения (разделителя) и деле-
ние исходной строки в соответствии с этим на массив строк.
```
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 171

Вопрос 5.  
Какие разновидности конструкторов использует класс String?  
**Ответ:** Класс ```String``` поддерживает несколько конструкторов, например: ```String(),
String(String str), String(byte[] asciichar), String(char[] unicodechar),
String(StringBuffer sbuf), String(StringBuilder sbuild) и др.``` Эти конструкторы
используются для создания объектов класса String на основе инициализации
значениями из массива типа char, byte и др. Например, при вызове конструктора
```java 
new String(str.getBytes(), "UTF-8")
```
можно установить кодировку создаваемому экземпляру в качестве второго
параметра конструктора. Когда Java встречает литерал, заключенный в двойные
кавычки, автоматически создается объект-литерал типа String, на который можно установить ссылку. Таким образом, объект класса String можно создать, при-
своив ссылке на класс значение существующего литерала или с помощью оператора ```new``` и конструктора, например:
```java 
String s1 = "oracle.com";
String s2 = new String("oracle.com");
``` 
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 170-171  

Вопрос 6.  
Какие классы в стандартной библиотеке Java работают со строками?  
**Ответ:** Классы ```StringBuilder и StringBuffer``` являются «близнецами» и по своему
предназначению близки к классу ```String``` , но в отличие от последнего содержимое и размеры объектов классов ```StringBuilder и StringBuffer``` можно изменять.
С помощью соответствующих методов и конструкторов объекты классов
```StringBuffer, StringBuilder и String``` можно преобразовывать друг в друга. 
Так же со строками работают классы ``` Formatter, Matcher, Pattern```  
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 174  

Вопрос 7.  
Почему экземпляры класса String в Java неизменные и финализированные?  
**Ответ:**
Безопасность и ```String pool``` основные причины неизменяемости ```String в Java```.
Безопасность объекта неизменяемого класса ```String``` обусловлена такими фактами:  
1: вы можете передавать строку между потоками и не беспокоиться что она будет изменена   
2: нет проблем с синхронизацией (не нужно синхронизировать операции со ```String```)  
3: отсутствие утечек памяти   
4: в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. - неизменяемость позволяет избежать проблем с доступом   
5: возможность кэшировать ```hash code```  
```String pool``` позволяет экономить память и не создавать новые объекты для каждой повторяющийся строки. 
В случае с изменяемыми строками - изменение одной приводило бы к изменению всех строк одинакового содержания.  
**Источник:** http://tlazarenko.blogspot.com/2013/10/string-java.html  

Вопрос 8.  
Заполните ячейки таблицы (Да/Нет).
``` java 
Characteristic 				String		StringBuilder		StringBuffer
Неизменяемый (Immutable)?
Имеет пул (Pooled)?
Потокобезопасный (Thread-safe)?
Может изменять размер?
```
**Ответ:** 
``` java 
Characteristic 				String	                             StringBuilder		            StringBuffer
Неизменяемый (Immutable)?    Да                                        Нет                             Нет
Имеет пул (Pooled)?          Да                                        Нет                             Нет
Потокобезопасный (Thread-safe)? Да, за счет неизменяемости             Нет                       Да, за счет синхронизации 
Может изменять размер?       Нет                                        Да                              Да
```
**Источник:** https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java  
https://docs.oracle.com/javase/tutorial/java/data/buffers.html  

Вопрос 9.  
В чем разница и что общего между ```StringBuffer``` и ```StringBuilder```?  
**Ответ:**
Эти классы похожи, практически двойники, они имеют одинаковые конструкторы, одни и те же методы, которые одинаково используются. 
Единственное их различие состоит в том, что класс ```StringBuffer``` синхронизированный и потокобезопасный.
Более высокая скорость обработки есть следствие отсутствия потокобезопасности класса ```StringBuilder```.
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 174

Вопрос 10.  
Когда лучше использовать ```StringBuffer```, а когда ```StringBuilder```?  
**Ответ:**  
```StringBuilder``` следует применять, если не существует вероятности использования объекта в конкурирующих потоках для получения более высокой скорости обработки.
В остальных случаях лучше использовать ```StringBuffer```.  
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 174

Вопрос 11.  
Какие методы имеются в классах ```StringBuffer``` и ```StringBuilder```, которые отсутствуют в классе ```String```?  
**Ответ:**  
Следует обратить внимание на следующие методы:  
```void setLength(int n)```— установка размера буфера;  
```void ensureCapacity(int minimum)``` — установка гарантированного 
минимального размера буфера;  
```int capacity()``` — возвращение текущего размера буфера;  
```StringBuffer append(параметры)```— добавление к содержимому объекта  
строкового представления аргумента, который может быть символом, 
значением базового типа, массивом и строкой;  
```StringBuffer insert(параметры)``` — вставка символа, объекта или строки
в указанную позицию;  
```StringBuffer deleteCharAt(int index)``` — удаление символа;  
```StringBuffer delete(int start, int end)``` — удаление подстроки;  
```StringBuffer reverse()``` — обращение содержимого объекта.   
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 175


Вопрос 12.  
Какие методы сравнения строк имеются в строковых классах?  
**Ответ:**  
1:  
```boolean endsWith(String suffix)```
```boolean startsWith(String prefix)```	Возвращает, ```true``` если эта строка заканчивается или начинается с подстроки, указанной в качестве аргумента метода.  
2:  
```boolean startsWith(String prefix, int offset)```	Считает строку, начинающуюся с индекса ```offset```, и возвращает, ```true```если она начинается с подстроки, указанной в качестве аргумента.  
3:  
```int compareTo(String anotherString)```	Сравнивает две строки лексикографически. Возвращает целое число, указывающее, больше ли эта строка (результат> 0), равна (результат = 0) или меньше (результат <0) аргумента.  
4:  
```int compareToIgnoreCase(String str)```	Сравнивает две строки лексикографически, игнорируя различия в регистре. Возвращает целое число, указывающее, больше ли эта строка (результат> 0), равна (результат = 0) или меньше (результат <0) аргумента.  
5:  
```boolean equals(Object anObject)```	Возвращает, ```true``` если и только если аргумент является ```String``` объектом, который представляет ту же последовательность символов, что и этот объект.  
6:  
```boolean equalsIgnoreCase(String anotherString)```	Возвращает, ```true``` если и только если аргумент является ```String``` объектом, который представляет ту же последовательность символов, что и этот объект, игнорируя различия в регистре.  
7:  
```boolean regionMatches(int toffset, String other, int ooffset, int len)```	Проверяет, соответствует ли указанная область этой строки указанной области аргумента ```String```.
Область имеет длину ```len``` и начинается с индекса ```toffset``` для этой строки и ```ooffset``` для другой строки.  
8:  
```boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)```	Проверяет, соответствует ли указанная область этой строки указанной области аргумента ```String```.
Область имеет длину len и начинается с индекса ```toffset``` для этой строки и ```ooffset``` для другой строки.
Логический аргумент указывает, следует ли игнорировать регистр; если истина, то при сравнении символов регистр игнорируется.  
9:  
```boolean matches(String regex)```	Проверяет, соответствует ли эта строка указанному регулярному выражению. Регулярные выражения обсуждаются в уроке «Регулярные выражения».  
**Источник:** https://docs.oracle.com/javase/tutorial/java/data/comparestrings.html  

Вопрос 13.  
Используя функции строковых классов, написать фрагмент программы, 
которая будет определять, является ли строка палиндромом.  
**Ответ:** 
```java 
public boolean checkPolyindrome(String s)
StringBuilder sb = new StringBuilder(s);
return sb.toString().equals(sb.reverse().toString());
```
Данный метод будет определять, является ли строка палиндромом с помощью метода ```reverse()``` класса ```StringBuilder```  

Вопрос 14.  
Что появится в консоли в результате работы фрагмента программы?  
```java 
final String ZA = " за ";
String value = "ОТЧЕТ о перевозках пассажиров за январь 2019 г.";
String[] monthYear = value.split(ZA)[1].split(" ",3);
System.out.println(Arrays.toString(monthYear));
```
Поясните ответ.  
**Ответ:**  
Основная операция происходит в строке ```String[] monthYear = value.split(ZA)[1].split(" ",3);``` 
Используя метод ```split(ZA)``` создается массив элементам которого являются части строки до и после строки "за".
Далее ```[1]``` является индексом созданного массива, следующий вызов метода ```split()``` делает слудющее:  
Разделяет строку под индексом 1 первого массива на подстроки, разделителем является символ пробел, таким образом создается второй массив из слов, которые в строке разделены пробелами.
```limit 3``` указывается в методе ```split()``` указывает кол-во элементов которые будут разделены пробелами, по порядку.
Последняя строка фрагмента выводит в консоль все элементы массива объеденяя их в одну строку. Вывод будет следующим:  
```[январь, 2019, г.]```   

Вопрос 15.  
Что появится в консоли в результате работы фрагмента программы?  
```java 
String s4 = "1" + 2 + 3;
String s5 = 1 + 2 + "3";
System.out.println(s4);
System.out.println(s5);
```
Поясните ответ.  
**Ответ:**  
Первая строка создается с "1" таким образом следующие операции сложения трактуются как объединение строк.  
Вторая строка начинается с арифметической операции сложения, таким образом объединение строк происходит уже после вычисления арифметической операции,
т.е. в учатке ```+ "3"```
Вывод в консоль будет следующим:  
```
123
33
```



Вопрос 16.  
Что появится в консоли в результате работы фрагмента программы?  
```java 
String s = "abcde ";
System.out.println(s.trim().length());
System.out.println(s.charAt(4));
System.out.println(s.indexOf('e'));
System.out.println(s.indexOf("de"));
System.out.println(s.substring(2, 4).toUpperCase());
System.out.println(s.replace('a', '1'));
System.out.println(s.contains("DE"));
System.out.println(s.startsWith("a"));
```
Поясните ответ.  
**Ответ:** 
```
5  //метод trim() удаляет пробелы в начале и в конце строки, таким образом выводится длинна строки без последнего пробела
e  //метод charaAt() получает символ под индексом который был передан, т.е. под индексом 4
4  //метод indexOf('e') получает индекс символа , который был передан, т.е. по символу 'e'
3  //метод indexOf("de") работает так же как и предыдущий аналог только принимает строку
CD //метод substring() вырезает строку по индексам которые были переданы (2,4) где первый индекс - начало новой строки, второй индекс конец строки (не включительно)
метод toUpperCase() поднимает все символы строки в верхний регистр
1bcde //метод replace() заменяет символ 'a' в строке на символ '1'
false //метод contains("DE") проверяет есть ли в строке подстрока "DE" и выводит false если такая подстрока не была найдена
true  //методе startsWith() определяет, начинается ли заданная строка с указанной символьной строки "a"
```  

Вопрос 17.  
Что появится в консоли в результате работы фрагмента программы?  

```java 
StringBuilder b = new StringBuilder();
b.append(12345).append('-');
System.out.println(b.length());
System.out.println(b.indexOf("-"));
System.out.println(b.charAt(2));
StringBuilder b2 = b.reverse();
System.out.println(b.toString());
System.out.println(b == b2);
```
Поясните ответ.  
**Ответ:**  
```
//В первой страке мы создаем объект типа StringBuilder с именем b; 
// Мы используем данный класс т.к. у него есть удобный для нас метод revece();
// С помощью метода append(12345) мы задаем значение нашему объекту b, который до этого действия был "пустым". 
// Функционал метода append можно описать как "добавить к строке".
//метод append('-') добавляет символ к строке объекта, то есть добавляет в конец строки символ '-'
6 - Выводит длину b с учетом уже добавленного символа '-'
5 - метод indexOf() возвращает индекс добавленного символа '-'
3 - метод charAt() возвращает символ который имеет переданный индекс (2)
-54321 - метод revers() заменяет строку на его зеркальный вариант, метод toString() выводит объект в виде строки 
true - т.к. ссылка на объект b не изменилась, опертатор сравнения "==" возвращает true
```  

Вопрос 18.  
Что появится в консоли в результате работы фрагмента программы?  
```java 
StringBuilder s = new StringBuilder("abcde");
s.insert(1, '-').delete(3, 4);
System.out.println(s);
System.out.println(s.substring(2, 4));
```
Поясните ответ.  
**Ответ:**  
```
//метод insert вставляет элемент присваивая ему переданный индекс не заменяя предыдущий символ под этим индексом, а отодвинув все индексы справа на одну ячейку,
 в данном случае вставляется символ '-' под индексом 1 
a-bde // т.к. в предыдущей строке кода был вставлен новый символ, символ 'c' теперь получил индекс 3, метод delete()
удаляет все символы начиная от первого переданного индекса заканчивая вторым переданным индексом (не включительно), таким образом 
был удален символ под индексом 3, то есть символ 'c'
bd метод substring() обрезает строку начиная с первого переданного индекса до последнего символа с переданным индексом (не включительно)
```  

Вопрос 19.  
```java 
StringBuffer sb = new StringBuffer("abcde");  
sb.insert(2,"123");
sb.append("456");
sb.reverse();
```
Поясните ответ.  
**Ответ:**  
```
//методы StringBuffer работают аналогично методам StringBuilder
sb.insert(2,"123"); //метод insert() вставит новую строку "123" начиная с переданного символа.
подвинув каждый элемент внутренней строки на "123".length ячеек вправо. sb при выводе: ab123cde
sb.append("456"); // метод append() добавит строку "456" к внутренней строке объекта sb. sb при выводе ab123cde456 
sb.reverse(); // метод reverse() зеркально отразит строку. sb при выводе : 654edc321ba 
```

Вопрос 20.  
Каким образом можно сцепить строки Java?  
Назовите не менее 3 способов.
**Ответ:**  
1: С помощью оператора ```+```  
2: С помощью метода ```concat()``` — возвращает строку со значением строки, переданной в метод и приложенной к концу строки, используемой для вызова этого метода.  
3: С помощью ```StringBuilder``` класса. Пример:  
```java 
String s1 = "Hello, ";
String s2 = "EPAM";
String s3 = new StringBuilder(s1).append(s2).toString();
```  
4: С помощью ```StringBuffer``` класса. Пример:
```java 
String s1 = "Hello, ";
String s2 = "EPAM";
String s3 = new StringBuffer(s1).append(s2).toString();
```  

Вопрос 21.  
Чем отличаются пустая и нулевая строки?  
**Ответ:** Пустая строка - это экземпляр строки нулевой длины, тогда как null строка вообще не имеет значения.
Пустая строка (например, "") означает, что была создана строковая константа (неважно, что она пустая), и под нее было выделено определенное количество памяти. 
Нулевая строка (null) не требует выделения под нее памяти.
**Источник:** https://docs.oracle.com/javaee/7/tutorial/bean-validation002.htm  

Вопрос 22.  
В какой кодировке хранятся символы в строке?  
**Ответ:**  Для размещения символов используется формат Unicode, в соответствии с 
которым для каждого символа отводится два байта. В формате ```Unicode``` первый
байт содержит код управляющего символа или национального алфавита, а второй байт соответствует стандартному ```ASCII``` коду.
Любой символ можно представить в виде ```'\ucode'```, где ```code``` представляет двухбайтовый
шестнадцатеричный код символа.  
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 32  

Вопрос 23.  
Какие интерфейсы реализуют классы ```String, StringBuffer и StringBuilder```?  
**Ответ:** Классы ```String, StringBuffer, StringBuilder``` определены в пакете ```java.lang``` и доступны 
автоматически без объявления импорта. 
`String` реализует следующие интерфейсы `Serializable`, `CharSequence`, `Comparable<String>`; 
`StringBuffer` и `StringBuilder` реализуют следующие интерфейсы ```Serializable, Appendable, CharSequence```.
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/String.html  
https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html   

Вопрос 24.  
Что такое кодовые точки и кодовые единицы?  
**Ответ:**  
Кодовые точки:  
Кодовая точка относится к числу, соответствующему символу в кодированном наборе символов. 
Допустимый диапазон ```от U + 0000 до U + 10FFFF```. Среди них ```от U + 0000 до U + FFFF``` - 
основные символы, а от ```U + 10000 до U + 10FFFF``` - дополнительные символы.  
Единица кода:  
Единица кода: 1 или 2 16-битные последовательности, полученные путем кодирования кодовых точек. 
Кодовая точка основного символа напрямую представлена кодовой единицей того же значения, а кодовая точка дополнительного символа кодируется двумя кодовыми единицами. 
В этом диапазоне нет числа для представления символа, поэтому программа может распознает, что текущий символ является одиночным элементом. Основные символы или дополнительные символы двойного элемента.  
Кодовые точки и кодовые единицы:  
Единица кода - это 16-битный двоичный код, а кодовая точка - это один или два 16-битных двоичного кода. 
То есть одна кодовая точка может быть выражена как одна кодовая единица или две кодовые единицы.  
**Источник:** https://russianblogs.com/article/56331560288/  

Вопрос 25.  
Объясните назначение метода ```intern()```.
Что появится в консоли в результате работы фрагмента программы?
```java 
class GFG {
public static void main(String[] args) {
String s1 = new String("GFG");
String s2 = s1.intern();
System.out.println(s1 == s2);
System.out.println(s1.equals(s2));
String s3 = "GFG";
System.out.println(s2 == s3);
}
}
```
Поясните ответ.  
**Ответ:** ```String intern()``` — заносит строку в «пул» литералов и возвращает ее объект-
ную ссылку. Вызов метода ```intern()``` организует поиск в «пуле литералов» соответствующего значению объекта
литерала и при положительном результате возвращает ссылку на найденный
литерал, а при отрицательном — заносит значение в пул и возвращает ссылку
на него. В данном случае вывод будет следующим:  
```java 
false // s1 и s2 имеют разные ссылки на объект, т.к. метод intern() не находит в пуле литералов соответсвующего значения.
true // метод equals() сравнил строки по значения (не ссылки на объект) и подтвердил их идентичность
true // после метода intern() строка s2 имеет ссылку на литерал, который был внесен от s1 то есть на "GFG" таким образом 
при инициализации строки s3 (которая инициализируется идентичным литералом) s3 получается на ссылку на тот же что и s2, т.к. такой литерал уже есть в пуле литералов.
```
**Источник:** Разбор на примере - И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 174  

Вопрос 26.  
Как преобразовать строку в число?  
**Ответ:** В ```Number``` подклассах , что типы обертывания примитивных числовые ```( Byte, Integer, Double, Float, Long, и Short)``` 
каждый из них предоставляет метод класса с именем , ```valueOf``` который преобразует строку в объект этого типа.  
**Источник:** https://docs.oracle.com/javase/tutorial/java/data/converting.html  

Вопрос 27.  
Какой метод вызывается для преобразования переменной в строку?  
**Ответ:** Каждый из ```Number``` подклассов включает метод класса ```toString()```, который преобразует его примитивный тип в строку. 
Метод ```String.valueOf()``` преобразовывает примитивные числовые переменные в строку.  
**Источник:** https://docs.oracle.com/javase/tutorial/java/data/converting.html  

Вопрос 28.  
Каким методом в классе ```String``` можно проверить строку на соответствие регулярному выражению?  
**Ответ:** ```boolean matches(String regex)``` - Проверяет, соответствует ли эта строка указанному регулярному выражению. Регулярные выражения обсуждаются в уроке «Регулярные выражения».  
**Источник:** https://docs.oracle.com/javase/tutorial/java/data/comparestrings.html  

Вопрос 29.  
Создайте класс с полями: int, long, float и double, String.
Сделайте для этого класса метод toString(), использующий String.format(), и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.  
**Ответ:**  
```java 
class StringFormatElement {
    private int i = 523123123;
    private long l = 521352131231123123L;
    private float f = 25.2F;
    private double d = 71.02;
    private String st = "my string";
    
    public static void main(String[] args) {
        StringFormatElement s = new StringFormatElement();
        System.out.println(s);
    }

    @Override
    public String toString() {
        return String.format("%d;%d;%f;%f;%s",i,l,f,d,st);
    }
}
```

Вопрос 30.  
Опишите:  
а: назначение класса ```Formatter```  
б: методы ```format()```  
в: спецификаторы формата  
**Ответ:**
а) Для создания форматированного текстового вывода предназначен класс
```java.util.Formatter```. Этот класс обеспечивает преобразование формата,
позволяющее выводить числа, строки, время и даты в любом необходимом разработчику виде.  
б) В классе ```Formatter``` объявлен метод ```format()```, который преобразует передан-
ные в него параметры в строку заданного формата и сохраняет в объекте типа
```Formatter```.  
в) 
```
%a Шестнадцатеричное значение с плавающей точкой
%b Логическое (булево) значение аргумента
%c Символьное представление аргумента
%d Десятичное целое значение аргумента
%h Хэш-код аргумента
%e Экспоненциальное представление аргумента
%f Десятичное значение с плавающей точкой
%g Выбирает более короткое представление из двух: %е или %f %o Восьмеричное целое значение аргумента
%n Вставка символа новой строки
%s Строковое представление аргумента
%t Время и дата
%x Шестнадцатеричное целое значение аргумента
%% Вставка знака %
```  
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 189  

Вопрос 31.  
а) Что представляет собой регулярное выражение?  
б) На каких классах базируются regex-возможности языка Java?  
в) В каком пакете эти классы расположены?  
**Ответ:**  
а) Регулярные вырожения - это шаблоны, по которым ищется соответствие в строке, файле
или другом объекте, представляющем последовательность символов.  
б) Для обработки строк используются классы ```Pattern и Matcher```.
Класс ```Pattern``` используется для простой обработки строк. Для более слож-
ной обработки строк используется класс ```Matcher```.  
в) Данные классы находятся в пакете ```java.util.regex```.  
**Источник:**  И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 177-178

Вопрос 32.  
а) Опишите назначение классов Pattern и Matcher.  
б) Каким образом они связываются?  
в) Предоставить простейший код их взаимодействия.  
**Ответ:**  
а) Класс ```java.util.regex.Pattern``` применяется для определения регулярных
выражений (шаблонов), для которых ищется соответствие в строке, файле
или другом объекте, представляющем последовательность символов.
О каждом соответствии можно получить информацию с помощью класса
```java.util.regex.Matcher```.
С помощью метода ```matches()``` класса ```Pattern``` можно проверять на соответствие шаблону целую строку, но если необходимо найти соответствия внутри
строки, например, определять участки, которые соответствуют шаблону, то
класс ```Pattern``` не может быть использован. Для таких операций необходимо
использовать класс ```Matcher```.  
б) Что бы использовать класс ```Matcher``` вначале надо создать объект ```Pattern``` 
с помощью статического метода ```compile()```, который позволяет установить шаблон:  
```java 
Pattern pattern = Pattern.compile("Hello");
```
В классе ```Pattern``` также определен метод ```matcher(String input)```, который в качестве параметра 
принимает строку, где надо проводить поиск, и возвращает объект ```Matcher```   
в) Пример:  
```java 
String input = "Hello world! Hello Java!";
Pattern pattern = Pattern.compile("Hello");
Matcher matcher = pattern.matcher(input);
```
Вопрос 33.  
При помощи регулярных выражений найти все ссылки внутри веб-страницы, 
то есть адреса, указанные в атрибуте ```href```.  
**Ответ:**  
```java
Pattern p = Pattern.compile("href=\"(.*?)\"");
Matcher m = p.matcher(belGutHtml);
while (m.find()) {
System.out.println(m.group(1));
}
```
**Источник:**  https://seoblog.life/other/regexp-primery.html

Вопрос 34.  
Какой из способов сравнения строк предпочтительнее?  
```str.equals("abc");```
или
```"abc".equals(str);```
Поясните ответ.  
**Ответ:** Предпочтительнее второй вариант, т.к. у первого есть недостаток - он может не работать, если ```str == null```  

Вопрос 35.  
Как сравнить объекты StringBuilder и StringBuffer?  
**Ответ:**  
Для классов ```StringBuffer и StringBuilder``` не переопределены методы ```equals()```
и ```hashCode()```, т. е. сравнить содержимое двух объектов невозможно, 
следовательно хэш-коды всех объектов этого типа вычисляются так же, как и для 
класса ```Object```. При идентичном содержимом у двух экземпляров, размеры буфера
каждого могут отличаться, поэтому сравнение на эквивалентность объектов
представляется неоднозначным.
Сравнить содержимое можно следующим образом:
```java 
StringBuffer sb1 = new StringBuffer(48);
StringBuilder sb2 = new StringBuilder(48);
sb2.toString().contentEquals(sb1);
```
Метод  ```contentEquals()```  проводит сравнение строки и содержимого объекта типа ```StringBuffer```;  
**Источник:**  И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 171

Вопрос 36.  
Что появится в консоли в результате работы фрагмента программы?  
```java 
System.out.printf("%d студентов пришли сдавать зачет по %8.10s, \n"
+ "из них не сдали %d, %s",
10, "J2SE", 5, "а остальные сдали на отлично"
);
```
Поясните ответ.  
**Ответ:**  
```
// System.out.printf выводит в консоль данные форматируя строку как и String.format() 
10 студентов пришли сдавать зачет по     J2SE, // вместо %d в начале строки будет вставлено целочисленная переменная идущая первая по порядку, т.е. 10
%8.10s указывает растояние до следущей строки  s = "J2SE" в пробелах. То есть 8.10 длина пробельного расстояния. 
из них не сдали 5, а остальные сдали на отлично // %d и %s будут заменены на следующие по порядку числовую переменную и строковое значение соотвественно
т.е. на 5 и строку = "а остальные сдали на отлично"
```  

Вопрос 37.  
Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с "http" или "https" и заканчивающиеся на "by".  
**Ответ:**  
```java
String regForSearch = "(https|http)://www.(.+)(by/)"
```
**Источник:**  

Вопрос 38.  
Сформировать регулярное выражение, при помощи которого можно выбрать все значения URL-запроса с ресурса ```https://bsut.by.```
Например, запрос ```https://bsut.by?value1=5&value2=10&iscan=true.```
Вывод
```java 
value1=5
value2=10
iscan=true 
``` 
**Ответ:**  
```java
String regString = "[?&]";
```  


Вопрос 39.  
Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). 
Специальные символы, основные логические конструкции, предопределенные классы символов, 
логические операции, квантификаторы, группы.  
**Ответ:**  
конструкции:\
`[abc]` - a или b или c.\
`[^abc]` - символ, исключая a, b и c.\
`[a-z]` - символ между a и z.\
спец символы:\
`.` - любой символ\
`\d` или `\p{Digit}` - [0-9]\
`\D` - [^0-9]\
`\s` или \p{Space} -[ \t\n\x0B\f\r]\
`\S` - [^\s]\
`\w` - [0-9_A-Za-z]\
`\W` - [^\w]\
`^` или `\A` - начало строки\
`$` или `\Z` - конец строки\
логические конструкции:\
`ab` - после а следует b\
`a|b` - a или b\
квантификаторы:\
`a?` - a один раз или ни разу\
`a*` - a ноль или более раз\
`a+` - a один или более раз\
`a{n}` - a n раз\
`a{n,}`  - a n или более раз\
`a{n,m}` - a от n до m\
Группы — способ обработки набора символов как одного.\
Каждая открывающая скобка слева направо нумерует группу. Выражение `((A)(B(C)))` определяет четыре группы:\
• ((A)(B(C)))\
• (A)\
• (B(C))\
• (C)\
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 234

Вопрос 40.  
Назовите основные, на ваш взгляд, методы класса ```Pattern```.  
**Ответ:**  
```Pattern compile(String regex)``` — возвращает ```Pattern```, который соответствует ```regex```  
```boolean matches(String regex, CharSequence input)``` — проверяет на соответствие строки ```input``` шаблону ```regex```  
```String[] split(CharSequence input)``` — разбивает строку ```input```, учитывая, что
разделителем является шаблон  
```Matcher matcher(CharSequence input)``` — возвращает ```Matcher```, с помощью которого можно находить соответствия в строке ```input```.  
**Источник:**  И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 171

Вопрос 41.  
Назовите основные, на ваш взгляд, методы класса ```Matcher```.  
**Ответ:**  
```boolean matches()``` — проверяет, соответствует ли вся информация шаблону  
```boolean find() или boolean find(int start)``` — ищет последовательность символов, 
соответствующих шаблону, в любом месте строки. Параметр ```start``` 
указывает на начальную позицию поиска.  
```replaceAll(String replacement)``` используется для замены всех подпоследовательностей символов, удовлетворяющих шаблону,
на заданную строку можно применить.   
метод ```reset()``` или ```reset(CharSequence input)```, который
также устанавливает новую последовательность символов для поиска.  
```String group()``` — возвращает всю подпоследовательность, удовлетворяющую шаблону;  
```int start()``` — возвращает индекс первого символа подпоследовательности,
удовлетворяющей шаблону;  
```int start(int group)``` — возвращает индекс первого символа указанной группы;  
```int end()``` — возвращает индекс последнего символа подпоследовательности, удовлетворяющей шаблону;
```int end(int group)``` — возвращает индекс последнего символа указанной группы;  
```String group(int group)``` — возвращает конкретную группу по позиции;  
```boolean hitEnd()``` — возвращает истину, если был достигнут конец входной
последовательности  
**Источник:**  И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 171


Вопрос 42.
Что появится в консоли в результате работы фрагмента программы?
```java 
System.out.println{"-1234".matches("-?\\d+"));
System. out. println ("5678". matches (" - ? \ \d+"));
System.out.println("+9ll".matches("-?\\d+"));
System.out.println("+911".matches("(-|\\+)?\\d+"));
```
Поясните ответ.  
**Ответ:**  
``` 
true /* регулярное выражение соотвествует заданной строке. -? подразумевает что - необязателен
      \\d+ - один или несколько элементов числового символа
      */
Error : illegal escape character т.к. в регулярном выражении попадают на сопоставление символы \ разделенные пробелами.
Если рассматривать выражение без пробелов т.е. System. out. println ("5678". matches ("-?\\d+")); Тогда результатом будет true;
1
false /* регулярное выражение не соответсвует заданной строке. -? проверку проходит (см. первую строку ответа)
однако \\d+ не проходит проверку на соотвествие т.к. после числового символа 9 стоят 2 буквенных символа l, 
регулярное выражение не указывает что после \\d могут стоят буквенные символы либо любые другие. 
*/
true /* регулярное выражение соотвествует заданной строке. | - знак "или", в данном случае предполагает
что в начале строки будет стоять либо '-' либо '+' далее уже разобранное выше регулярное выраженеи с числовыми символами.
*/
```

Вопрос 43.  
Что появится в консоли в результате работы фрагмента программы?  
```java  
System.out.println(
Arrays
.toString("Then, when you have found the gold."
.split("n\\W+")
)
);
```
Поясните ответ.  
**Ответ:**  
```[The, whe, you have found the gold.]``` 
В данном случае ```split("n\\W+")``` разделяет строку на подстроки, и вносит их в массив, который после выводится в консоль.
Регулярное выражение для разделение подразумевает некую подстроку начинающуюся на "n" имеющее хотя бы 1 символ кроме буквенного, числового или нижнего подчеркивания.  

Вопрос 44.  
Сформируйте и протестируйте регулярное выражение, которое проверяет, что предложение начинается с прописной буквы и завершается точкой.  
**Ответ:** 
```java 
System.out.println("Hey! It's some string --> 23.".matches("(\\p{Upper})(.+)(\\.)");
```

Вопрос 45.  
Сформируйте и протестируйте регулярное выражение, которое заменяет все гласные подчеркиваниями в предложении
"Then, when you have found the gold".  
**Ответ:**  
```java 
System.out.println("Then, when You have found the gold".
                replaceAll("(?i)[aouyie]","_"));
```

Вопрос 46.
Определите, будет ли найдено в строке
"Java now has regular expressions"
совпадение для следующих выражений:
```java 
^Java\Breg.*n.w\s+h(a|i)ss?s*s+S{4}S{1}S{0,3}
```
Поясните ответ.  
**Ответ:**  
Предполагаю что регулярное выражение должны выглядеть так:
```java 
^Java\\Breg.*n.w\\s+h(a|i)ss?\\s*\\s+\\S{4}\\S{1}\\S{0,3}
```
В таком случае выводом будет false;
```java 
^Java // Начало строки - Java = true
\Breg.* // \B - не граница слова = ??
n.w\s+h(a|i)s // n + любой символ + w + \\s = пробел + h + a или i + s === true
s? s - либо один раз встречается либо отсутсвует == true 
\\s* s - встречается 0 или более раз = true
\\s+ s - встречается 1 или более раз = true 
\\S{4} - 4 повтора символа "S" = true
\\S{1} - 1 непробельный символ = true
\\S{0,3} - 0-3 непробельных символа = true
```
Корректная проверка:  
```java 
System.out.println("Java now has regular expressions".
                matches("^Java.*n.w\\s+h(a|i)ss?\\s+\\S{4}\\S{1}\\S{0,3}.*"));
```
Вопрос 47.  
Примените регулярное выражение  
```(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b```
к строке
"Arline ate eight apples and one orange while Anita hadn't any"
Поясните ответ.  
**Ответ:**
```java 
(?i) // допускает любой регистр для следующих символов = true
((^[aeiou])|(\s+[aeiou])) // либо начало строки начинается с гласной либо с пробела или нескольких, а затем гласной = true
\w+?[aeiou]\b после идет // после идет один или более символ равный буквенному, числовому или знаку подчеркивания = true
после гласная и граница слова = true
```
Если в конце регулярного выражение поставить ```.*``` тогда вывод будет ```true```, без этого данное выражение = ```false```;

Вопрос 48.  
Какие подстроки извлекают следующие регулярные выражения?  
**Ответ:**  
```java 
[0-6] - числовые символы от 0 до 6
[^n-p] - начало строки - символ от n до p (в нижнем регистре)
[A-Za-z0-9_] - все буквенные символы, числовые от 0 до 9 и нижнее подчеркивание
\w - все буквенные символы, числовые от 0 до 9 и нижнее подчеркивание
[A-C][n-p][a-c] - буквенные символы от a до c вне зависимости от регистра, от n до p в нижнем регистре
waz{3,5}up - wa + символ z повторяющийся от 3 до 5 раз + up
[abc]+ - символы a,b или c повторяющиеся один или более раз.
.* - любой символ повторяющийся 0 или более раз
```

Вопрос 49.  
Сформируйте регулярное выражение, которое находит предложения, 
начинающиеся с "Input:" и заканчивающиеся на "successful".  
**Ответ:** 
```java 
System.out.println("Input sta b 22 successful".
                matches("^(Input).*(successful)$")); 
                // ^ - начало строки соответсвует тому что в скобках
                // .* - любой символ повторяющийся 0 или более раз
                // $ - конец строки соотвествует тому что было заданно в скобках до знака
```
Вопрос 50  
Сформируйте регулярное выражение, которое выделяет в обрабатываемом тексте 
названия файлов (имя + расширение) графических форматов ```gif, png, jpg```.  
**Ответ:** 
```java 
System.out.println("in.png".
                matches(".*\\.((gif)|(png)|(jpg))$"));
```