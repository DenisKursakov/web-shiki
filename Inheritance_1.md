**Theory**

(1) Как по терминологии Java называются базовый класс и наследуемый класс?
**Ответ:**
Класс, производный от другого класса, называется подклассом (также производным классом , расширенным классом или дочерним классом ). 
Класс, от которого происходит подкласс, называется суперклассом (также базовым классом или родительским классом ).
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html
(2) Какой класс является родительским для всех классов?
**Ответ:**
Каждый класс имеет один и только один прямой суперкласс (одиночное наследование). В отсутствие какого-либо другого явного суперкласса каждый класс неявно является подклассом ``Object``.
Классы могут быть производными от классов, которые являются производными от классов, производных от классов и т. Д., И в конечном итоге производными от самого верхнего класса ``Object``. 
Такой класс считается потомком всех классов в цепочке наследования, начиная с ``Object``.
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html
(3) Какой класс является родительским для всех перечислений?
**Ответ:**
Все перечисления неявно расширяются ``java.lang.Enum``. Поскольку класс может расширять только одного родителя,
язык Java не поддерживает множественное наследование состояния, и поэтому перечисление не может расширять что-либо еще.
**Источник:** https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html
(4) Какой интерфейс является родительским для всех интерфейсов?
**Ответ:**
В языке программирования Java интерфейс - это ссылочный тип, подобный классу, который может содержать только константы, сигнатуры методов, методы по умолчанию, статические методы и вложенные типы. 
Тела методов существуют только для методов по умолчанию и статических методов. Интерфейсы не могут быть созданы - они могут быть реализованы только классами или расширены другими интерфейсами.
Родительского интерфейса для всех всех интерфейсов нет.
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html
(5) Сформулируйте критерий отношения наследования между двумя сущности
физического мира.
Другими словами, какому условию должны удовлетворять две сущности физического
мира, чтобы соответствующие им классы были связаны отношением наследования?
**Ответ:** Есть принцип Лисков, третья буква в абревиатуре SOLID, который утверждает, что наследуемый класс должен дополнять, а не замещать поведение базового класса. 
Об этом, кстати, прямо намекает ключевое слово extends в Java.
Наследование полезнее всего для группировки сходных сущностей и понятий, определения семейств классов, и вообще для организации терминов и понятий, описывающих предметную область. 
Зачастую, когда значительная часть предметной логики уже реализована, исходно выбранные иерархии наследования перестают работать. Если всё к тому идет, не бойтесь разобрать и заново сложить эти иерархии так, чтобы они лучше соответствовали и работали друг с другом.
**Источник:** https://dou.ua/lenta/articles/composition-vs-inheritance-in-java/
              https://habr.com/ru/post/325478/
(6) Есть ли отношение наследования между сущностями:
а) квадрат и прямоугольник;
б) сосна и доска;
в) книга и страница?
Поясните ответ.
**Ответ:**
Принцип подстановки Лисков или принцип определения подтипа на основе поведения (strong behavioral typing) классов: 
если можно написать хоть какой-то осмысленный код, в котором замена объекта базового класса на объекта класса потомка, его сломает, то тогда не стоит их друг от друга-то наследовать.
а) Если рассматривать квадрат как предка от прямоугольника то отношение наследования логично, т.к. квадрат можно представить как прямоугольник с равными сторонами.
И переопределить метод вычисления, к примеру, периметра. Однако по принципу подстановки Лискова такое наследование может быть проблемотичным.
С геометрической точки зрения, квадрат — это прямоугольник. С точки зрения иерархии наследования классов, будет ли класс квадрата наследником класса прямоугольник, зависит от того поведения, которое мы требуем от этих классов. Зависит от того, как и в каких ситуациях мы используем этого код.
В данном случае более логично наследовать "квадрат от класса фигура"
б) В данном случае отношение наследования отсутсвует, т.к. доска это материал, полученный с помощью сосны. 
Соотвественно она не расширяет класс "сосна", более того несет координально отличающийся функционал.
в) К отношение книги и страницы логиченее описать как Композицию, книга состоит из страниц, и без страниц ее существование не имеет смысла.
Соответсвенно наследование в данном случае так же не логично. 
**Источник:** https://habr.com/ru/post/463385/
(7) В jdk класс ``RuntimeException`` является подклассом ``Exception``.
Есть ли нарушение критерия наследования?
Поясните ответ.
**Ответ:**
``RuntimeException`` наследуется от ``Exception`` потому-что непроверяемое исключение это все еще исключение, а не ошибка: его можно обработать и оно всегда зависит от кода, а не от сторонних, системных, факторов. И если разработчик решит обрабатывать все исключения:
, то должны обрабатываться и возникшие ``RuntimeException``.
Итог: ``RuntimeException (unchecked)``, наследуется от класса ``Exception``, который является ``(checked)`` по следующим причинам:
 Проверяемость тех или иных классов явно прописана в спецификации и не связана с какими-либо свойствами классов-исключений. Наследование имеет чисто организационный/иллюстративный характер и не связано с наследованием свойств/методов.
 Проверяемое исключение — это исключение, а не ошибка, и должно обрабатываться как исключение.
 Разработчики Java приняли решение, что базовый класс исключений должен быть проверяемым.
**Источник:** https://ru.stackoverflow.com/questions/903495/Исключения-и-странное-наследование.
(8) В чем смысл конструкции ``super``?
Перечислите случаи, когда используется конструкция super.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими
возможностями. Если можно, то каким образом?
**Ответ:**
Если ваш метод переопределяет один из методов своего суперкласса, вы можете вызвать переопределенный метод с помощью ключевого слова ``super``. 
Вы также можете использовать ``super`` для ссылки на скрытое поле (хотя скрытие полей не рекомендуется).
С ``super()`` вызывается конструктор суперкласса без аргументов. С ``super(parameter list)`` вызывается конструктор суперкласса с соответствующим списком параметров.
Вызов конструктора суперкласса должен быть первой строкой в конструкторе подкласса.
Примечание.  Если конструктор не вызывает явно конструктор суперкласса, компилятор Java автоматически вставляет вызов в конструктор суперкласса без аргументов. Если суперкласс не имеет конструктора без аргументов, вы получите ошибку времени компиляции. 
``Object`` действительно есть такой конструктор, так что если ``Object`` это единственный суперкласс, нет никаких проблем.
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/super.html
(9) Можно ли одновременно использовать ``this()`` и ``super()`` в конструкторе?
Поясните ответ.
**Ответ.** Нет. this() вызывает конструктор данного класса, ``super()`` - конструктор класса-родителя. Обе инструкции должны
находиться на первой строке конструктора, что физически невозможно
**Источник.**  https://docs.oracle.com/javase/tutorial/java/IandI/super.html
(10) Дан код.
class SomeClass() {
...
public SomeClass() {
doSmth();
}
protected void doSmth() {
...
}
}
Это потенциальный антипаттерн. Почему?
**Ответ:**
Не рекомендуется вызывать public и protected методы. 
Если класс не финальный, открытые методы могут быть переопределены в подклассе, и тогда в вашем конструкторе будут вызываться не ваши методы, а переопределенные, что может сломать логику работы вашего класса и привести к ошибке.
Соотвественно модификатор доступа метода должен быть private.
**Источник:** https://qna.habr.com/q/279444
(11) Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все
методы, объявленные в интерфейсе?
**Ответ:** Класс может реализовывать интерфейс. Реализация интерфейса заключается в том, что в описании класса данный интерфейс указывается как реализуемый, а в коде класса обязательно определяются все методы, которые описаны в интерфейсе, в полном соответствии с сигнатурами из описания этого интерфейса. То есть, если класс реализует интерфейс, для любого экземпляра этого класса существуют и могут быть вызваны все описанные в интерфейсе методы. 
Один класс может реализовать несколько интерфейсов одновременно.
**Источник:** https://ru.wikipedia.org/wiki/Интерфейс_(объектно-ориентированное_программирование)
(12) Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?
**Ответ:** 
Это называется ``Tagged`` или ``Marker interface``. Они не используются для использования или эксплуатации. Эти методы используются для маркировки или маркировки класса. 
Чтобы определить, является ли класс дочерним элементом этих классов.
Интерфейс-маркер, маркер (англ. marker interface pattern) — это шаблон проектирования, применяемый в языках программирования с проверкой типов во время выполнения. Шаблон предоставляет возможность связать метаданные (интерфейс) с классом даже при отсутствии в языке явной поддержки для метаданных.
Чтобы использовать эту модель, класс реализует интерфейс[1] («помечается интерфейсом»), а взаимодействующие с классом методы проверяют наличие интерфейса. 
В отличие от обычного интерфейса, который определяет функциональность (в виде объявлений методов и свойств), которой должен обладать реализуемый класс объектов, важен сам факт обладания класса маркером. Маркер лишь является признаком наличия определённого поведения у объектов класса, помеченного маркером. Разумеется, возможны и «смешанные» интерфейсы, однако при неаккуратном использовании они могут создавать путаницу.
**Источник:** https://ru.wikipedia.org/wiki/Интерфейс-маркер_(шаблон_проектирования)
(13) Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в
этом классе?
**Ответ:**
Когда переопределенный метод вызывается через ссылку супер-
класса, Java определяет, какую версию метода вызвать, основываясь на типе
объекта, на который имеется ссылка. Таким образом, тип объекта определяет
версию метода на этапе выполнения.
Исходя из этого можно сделать вывод, что переопределние метода в одном и том же классе не допустимо,
т.к. компилятор выбирает для реализации только один метод со идентичным названием и типом переданных данных.
Для изменения функционала метода используется перегрузка метода.
Вы можете перегрузить методы, это новые методы, уникальные для класса.
**Источник:** Блинов стр. 129. https://docs.oracle.com/javase/tutorial/java/IandI/override.html
(14) Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?
**Ответ:**
Да, если объявление метода подкласса полностью, включая параметры, совпа-
дает с объявлением метода суперкласса (порождающего класса), то метод под-
класса переопределяет (overriding) метод суперкласса. Переопределение мето-
дов является основой концепции динамического связывания, реализующей
полиморфизм. Когда переопределенный метод вызывается через ссылку супер-
класса, Java определяет, какую версию метода вызвать, основываясь на типе
объекта, на который имеется ссылка. Таким образом, тип объекта определяет
версию метода на этапе выполнения.
Для изменения функционала метода используется перегрузка метода.
В подклассе вы можете перегрузить методы, унаследованные от суперкласса.
Такие перегруженные методы не скрывают и не переопределяют методы экземпляра суперкласса - это новые методы, уникальные для подкласса.
**Источник:** Блинов стр. 129. https://docs.oracle.com/javase/tutorial/java/IandI/override.html
(15) Можно ли переопределить статический метод? Поясните ответ.
**Ответ:**Если подкласс определяет статический метод с той же сигнатурой, что и статический метод в суперклассе, то метод в подклассе скрывает метод в суперклассе.
Различие между скрытием статического метода и переопределением метода экземпляра имеет важные последствия:
-Вызывается версия метода переопределенного экземпляра, содержащаяся в подклассе.
-Версия вызываемого скрытого статического метода зависит от того, вызывается он из суперкласса или подкласса.
Вызываемая версия скрытого статического метода находится в суперклассе, а вызываемая версия переопределенного метода экземпляра - в подклассе.
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/override.html
(16) Как запретить переопределение метода в подклассе? Назовите 2 способа.
**Ответ:** 
1 - Хотя переопределение методов — одно из наиболее мощных средств Java, в некоторых случаях его желательно избежать. 
Чтобы запретить переопределение метода, в начале его объявления необходимо указать ключевое слово final. Методы, объявленные как final, переопределяться не могут.
2 - Дать коду модификатор доступа private.
**Источник:** http://www.linkex.ru/java/final-no-overriding.php
(17) С помощью какого механизма реализуется полиморфизм в Java?
**Ответ:**
Механизм «позднего связывания» или «динамического полиморфизма»
в процессе выполнения программы определяет принадлежность объекта кон-
кретному классу и производит вызов метода, относящегося к классу, объект
которого был использован. Механизм «позднего связывания» позволяет опре-
делять версию полиморфного (виртуального) метода во время выполнения
программы, то есть невозможно на этапе компиляции определить, какая версия
переопределенного метода будет вызвана на этапе выполнения программы.
**Источник:** Блинов стр. 65-66.
(18) Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть
ссылка на объект суперкласса? Если да, то как ее получить?
**Ответ:** Да, Вы также можете использовать ``super`` для ссылки на скрытое поле (хотя скрытие полей не рекомендуется).
Ссылка на объект суперкласса получается с помощью ``super``.
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/super.html
(19) SmallEntity и BigEntity - это подклассы Entity.
Можно ли отрефакторить данный код? Если да, то выполните.
class EntityFactory {
public static Entity getEntity(int num) {
switch(num) {
case 2: return new Entity();
case 3: return new SmallEntity();

case 4: return new BigEntity();
default: throw new IllegalArgumentException();
}
}
}
**Ответ:** Если классы BigEntity и SmallEntity являютяс наследниками класса и это прописано в коде наслдеников 
с помощью ``extends`` то код будет работать исправно и не требует корректировки.
**Источник:**
(20) Можно ли отрефакторить данный код? Если да, то выполните.
class Entity {
...
private String action;
public void doSmth() {
switch(action) {
case "sing-solo": singSolo(); break;
case "sing-duet": singDuet(); break;
case "dance": dance();
}
}
private void singSolo() {
...
}
private void singDuet() {
...
}
private void dance() {
...
}
}
**Ответ:**
```
class Entity {
    enum Cases{
        SING_SOLO {
            void doSmth() {
            }
        },
        SING_DUET {
            void doSmth() {
            }
        },
        DANCE{
            void doSmth() {
            }
        };
        abstract void doSmth();
    }
}
```
**Источник:** Блинов раздел Перечисления стр.96 - 100
(21) Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли
создать объект класса В по ссылке а?
**Ответ:** 
Класс А - абстрактный класс, соответсвенно мы не можем создать объект класса А.
Объекты таких классов нельзя создать с помощью оператора new, но можно
создать объекты подклассов, которые реализуют все эти методы. При этом
допустимо объявлять ссылку на абстрактный класс, но инициализировать ее
можно только объектом производного от него класса. 
Подкласс Б может иметь собственный объект класса, мы можем создать объект класса Б используя
его супер класс А :
```
public abstrat class A {
...
}
public class B extends A {
...
}
public class Runner {
public static void main(String[] args){
     A a = new B(); \\ create a new class B object 
}
}
```
Такое создание объекта допустимо, более того удобно и частно используется.
**Источник:** Блинов стр 134 (НАСЛЕДОВАНИЕ И ПОЛИМОРФИЗМ)
(22) Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс
I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:
1. b = i; ?
2. i = b; ?
   В чем заключается отличие сравнения принадлежности к классу через операцию
   ``instanceof`` и метод ``getClass()``?
   Можно ли создать:
3. ссылку на объект абстрактного класса?
4. объект абстрактного класса?
5. ссылку на интерфейс?
6. объект типа интерфейс?
   Может ли класс:
7. реализовывать два интерфейса?

8. расширять два класса?
9. расширять два интерфейса?
10. расширять один класс и реализовывать один интерфейс?
11. расширять сам себя?
    Для каких целей используется расширение интерфейса?
    Могут ли в интерфейсе быть поля?
    Можно ли в интерфейсе
12. объявить метод с пакетным уровнем доступа?
13. объявить конструктор?
14. определить конструктор?
    Можно ли интерфейс объявить финальным? Поясните ответ.
    Можно ли в интерфейсе объявить статический метод? Поясните ответ.
**Ответ:**
I. Допустимо объявление ссылки на интерфейсный тип или использование ее
    в качестве параметра метода. Такая ссылка может указывать на экземпляр лю-
    бого класса, который реализует объявленный интерфейс. При вызове метода
    через такую ссылку будет вызываться его реализованная версия, основанная на
    текущем экземпляре класса. Выполняемый метод разыскивается динамически
    во время выполнения, что позволяет создавать классы позже кода, который вы-
    зывает их методы.
1 - Нет, данное сравнение подразумевает идентичность типов.
2 - С  помощью ``instanceof`` оператора можно выполнить логическую проверку типа конкретного объекта . 
Это может спасти вас от ошибки времени выполнения из-за неправильного приведения. Например:
``` if (obj instanceof MountainBike) {
    MountainBike myBike = (MountainBike) obj;
    }
```
Здесь ``instanceof`` оператор проверяет, что ``obj`` ссылается на a, ``MountainBike`` чтобы мы могли выполнить приведение, зная, что не будет генерироваться исключение времени выполнения.
Причина, по которой производительность ``instanceof`` и ``getClass() == ...`` отличается, заключается в том, что они делают разные вещи.
``instanceof`` проверяет, является ли ссылка на объект с левой стороны (LHS) экземпляром типа с правой стороны (RHS) или каким-либо подтипом .
``getClass() == ...`` проверяет, идентичны ли типы.
Поэтому рекомендуется игнорировать проблему производительности и использовать альтернативу, которая дает вам нужный ответ.
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html
              https://coderoad.ru/4989818/instanceof-Vs-getClass#4989843
3 - Да, как к примеру ссылка action на абстрактный суперкласс инициализируется объектом под-
класса, в котором реализованы все абстрактные методы суперкласса:
``` AbstractCardAction action;
// action = new AbstractCardAction(); //compile error: cannot create object!
action = new CreditCardAction();
action.doPayment(7); 
```
С помощью этой ссылки могут вызываться также и неабстрактные методы
абстрактного класса, если они не переопределены в подклассе:
**Источник:** Блинов стр. 135.
4 - Нет, объекты абстрактных классов нельзя создать с помощью оператора new, но можно
создать объекты подклассов, которые реализуют все астрактные классы родителя.
**Источник:** Блинов стр. 134.
5 - 
Переменные можно объявлять как объектные ссылки, которые используют тип интерфейса, а не тип класса. 
Посредством такой переменной можно ссылаться на любой экземпляр любого класса, реализующего объявленный интерфейс. 
При вызове метода с помощью одной из таких ссылок выбор нужной версии будет производиться в зависимости от конкретного экземпляра интерфейса, на который выполняется ссылка. 
Это — одна из главных особенностей интерфейсов. Поиск выполняемого метода осуществляется динамически во время выполнения, что позволяет создавать классы позже, чем код, который вызывает методы по отношению к этим классам. 
Диспетчеризация кода может выполняться посредством интерфейса без необходимости наличия каких-либо сведений о "вызывающем". 
Этот процесс аналогичен использованию ссылки на суперкласс для доступа к объекту подкласса.
**Источник:** http://www.linkex.ru/java/interface-references.php
6 - Нет, в языке программирования Java интерфейс - это ссылочный тип, подобный классу, который может содержать только константы, сигнатуры методов, методы по умолчанию, статические методы и вложенные типы. Тела методов существуют только для методов по умолчанию и статических методов. 
Интерфейсы не могут быть созданы - они могут быть реализованы только классами или расширены другими интерфейсами. Расширение обсуждается позже в этом уроке.
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html
7 - Класс может реализовывать любое число интерфейсов, указываемых через
запятую после ключевого слова implements, дополняющего определение клас-
са. После этого класс обязан реализовать все абстрактные методы, полученные
им от интерфейсов, или объявить себя абстрактным классом.
**Источник:** Блинов стр. 177.
8 - Наследование (inheritance) — процесс, посредством которого один класс
может наследовать поля и методы другого класса, изменять их и добавлять
к ним поля и методы, характерные только для его состояния и поведения.
• множественное наследование в Java для классов запрещено, а для интерфейсов разрешено.
Соответственно класс не может расширять более одного класса.
**Источник:** Блинов стр. 65.
9 - Нет,  Классы, интерфейсы только реализуют, а не расширяют. Класс может наследовать один
суперкласс и реализовывать произвольное число интерфейсов.
**Источник:** Блинов стр. 180.
10 - Да, расширение класса и реализация интерфейса допустимы.
Класс может наследовать один
суперкласс и реализовывать произвольное число интерфейсов.
**Источник:** Блинов стр. 180.
11 - Интерфейс могут расширяться только другими интерфейсами
Интерфейс содержит переменные и методы (поля), подобные классу, но методы интерфейса по умолчанию абстрактны в отличие от класса. 
Интерфейс расширяет другой интерфейс, как класс реализует интерфейс в наследовании интерфейса.
Таким образом интерфейс наследует методы родителя и в интерфейсе потомке можно добавить определный функционал 
дополнительно к родительскому. 
**Источник:** https://docs.oracle.com/javase/tutorial/java/IandI/nogrow.html
12 - Нет, все объявленные в интерфейсе абстрактные методы автоматически тракту-
ются как public abstract, а все поля — как public static final, даже если они так
не объявлены. Интерфейсы могут объявлять статические методы. В интерфей-
сах могут объявляться методы с реализацией с ключевым словом default. Эти
методы могут быть public или private.
**Источник:** Блинов стр.177
13, 14 - Интерфейс не содержит конструкторов. 
Интерфейс может объявлять статические методы.
Каждое объявление поля в тексте интерфейса неявно общедоступно, статично и окончательно. 
Разрешено избыточно указывать любые или все эти модификаторы для таких полей.
**Источник:**  http://proglang.su/java/interfaces Блинов стр.177

(23) Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.
**Ответ:**
Методы экземпляров - это логика, поля экземпляра - это данные. Вместе они образуют объект.
Без объекта нет данных экземпляра, и хотя методы экземпляра существуют как часть определения класса, 
им нужен экземпляр объекта для предоставления данных для них.
**Источник:** https://overcoder.net/q/25297/в-чем-причина-на-нестатический-метод-нельзя-ссылаться-из-статического-контекста#603932
(24) Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то
зачем?
**Ответ:**
Производный класс обязан переопределить и реализовать все абстрактные методы, которые имеются в базовом абстрактном классе. 
Также следует учитывать, что если класс имеет хотя бы один абстрактный метод, то данный класс должен быть определен как абстрактный.
Экземпляры абстрактного класса создавать нельзя.
**Источник:** https://metanit.com/java/tutorial/3.6.php
(25) Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то
зачем объявлять такой класс абстрактным?
**Ответ:**  Абстрактный класс может и не содержать
вовсе абстрактных методов. Предназначение такого класса — быть вершиной
иерархии его различных реализаций.
**Источник:** Блинов стр. 134.
(26) Что означает ключевое слово final в следующих конструкциях?
1.
public final class SomeClass() { }
2.
public class SomeClass() {
public final void doSmth();
}
**Ответ:**
1 - Если в системе необходим объект, внутреннее состояние которого нельзя
изменить, то процедура реализации такой задачи представляется в виде public final class.
Такой объект от создания и до уничтожения не может быть изменен, что
уменьшает затраты на безопасность при использовании в конкурирующих опе-
рациях.
2 - Что бы запретить переопределять метод в порожденном классе, если в суперклас-
се он объявлен со спецификатором final:
**Источник:** Блинов стр. 101. Блинов стр. 125
(27) Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.
**Ответ:** Финальный асбтрактный метод не имеет смысла для сущетсвования. Абстрактный метод предназначен
для его последующего переопределния у потомков или классов реализующих интерфейс. ```final``` запрещает
переопределять метод, соотвественно такое объявление бессмысленно.
**Источник:** Блинов стр. 125. 134.
(28) К каким методам неприменимы принципы позднего связывания? Почему?
**Ответ:** Метод называется перегруженным, если существует несколько его версий
с одним и тем же именем, но с разным списком параметров. Перегрузка реали-
зует «раннее связывание», то есть версия вызываемого метода определяется на
этапе компиляции.
**Источник:** Блинов стр. 86.
(29) В чем заключается отличие между ранним и поздним связыванием?
**Ответ:**
Перечислим ключевые различия между ранним и поздним связыванием в языке Java:
- Статическое связывание происходит во время компиляции, а динамическое – во время выполнения.
- Поскольку статическое связывание происходит на ранней стадии жизненного цикла программы, его называют ранним связыванием. 
Аналогично, динамическое связывание называют также поздним связыванием, поскольку оно происходит позже, во время работы программы.
- Статическое связывание используется в языке Java для разрешения перегруженных методов, в то время как динамическое связывание используется в языке Java для разрешения переопределенных методов.
- Аналогично, приватные, статические и терминальные методы разрешаются при помощи статического связывания, поскольку их нельзя переопределять, а все виртуальные методы разрешаются при помощи динамического связывания.
- В случае статического связывания используются не конкретные объекты, а информация о типе, то есть для обнаружения нужного метода используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода в Java используется конкретный объект.
**Источник:** https://javarush.ru/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java
Бонусное задание 1 (необязательное)
Добавить к задаче inheritance2 пункт:
8. Найти в отсортированном массиве ВСЕ покупки со стоимостью 5.00 BYN, для
   первоначального поиска использовав метод Arrays.binarySearch( ).

Желательно найти такое решение, которое после поиска позволяет выполнить задачу
за один цикл.
Трюки типа Arrays.copyOfRange() не засчитываются, т.к. они реализованы через цикл.
То есть если быть максимально точным, то должен быть один цикл, и вычислительная
сложность алгоритма после вызова метода Arrays.binarySearch( ) должна быть равна
O(n).
Подсказка 1 - это решение существует )
Подсказка 2
----------------- см. следующую строку -------------
В чем смысл отрицательного значения метода binarySearch()?
---------------------------------------------------------------