**Questions**  

(1) В какой версии Java появились параметризованные типы?  
**Ответ:** Так как в коллекциях при практическом программировании хранится набор
ссылок на объекты одного типа, следует обезопасить коллекцию от появления
ссылок на другие, не разрешенные логикой приложения типы. Такие ошибки
при использовании нетипизированных коллекций выявляются на стадии выполнения, что повышает трудозатраты на исправление и верификацию кода. Поэтому,
начиная с версии ```Java SE 5```, коллекции стали типизированными или ```generic```.  
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 321  

(2) Приведите 2 примера кода:  
а) первый без параметризованного типа;  
б) второй - этот же код с параметризованным типом, 
иллюстрирующий преимущество данного варианта.  
**Ответ:**
Код, использующий универсальные шаблоны, имеет много преимуществ перед неуниверсальным кодом:

1: Более строгие проверки типов во время компиляции.
Компилятор ```Java``` применяет строгую проверку типов к универсальному коду и выдает ошибки, если код нарушает безопасность типов. 
Исправлять ошибки времени компиляции проще, чем исправлять ошибки времени выполнения, которые бывает сложно найти.  

2: Устранение слепков.  
а) Следующий фрагмент кода без универсальных шаблонов требует приведения:
```java
public class Runner {
    public static void main(String[] args) {
        List list = new ArrayList();
        list.add("hello");
        String s = (String) list.get(0);
    }
}
```
б) При переписывании для использования дженериков код не требует приведения:
```java 
public class Runner {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("hello");
        String s = list.get(0);   // no cast
    }
}
```
3: Предоставление программистам возможности реализовать общие алгоритмы.
Используя универсальные шаблоны, программисты могут реализовать универсальные алгоритмы, которые работают с коллекциями разных типов, могут быть настроены, безопасны по типу и легче читаются.  
**Источник:** https://docs.oracle.com/javase/tutorial/java/generics/why.html  

(3) Какие типы данных запрещены в качестве параметров классов?  
**Ответ:** Переменная типа может быть любым указанным вами непримитивным типом: любым типом класса, любым типом интерфейса, любым типом массива или даже переменной другого типа.
В качестве параметров классов запрещено применять базовые типы.  
**Источник:** https://docs.oracle.com/javase/tutorial/java/generics/types.html  
И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 89  

(4) Дан код:
```java 
class Gen <T1, T2 extends Number, T3 extends Object> { … }
```
Какие типы можно использовать в качестве аргументов ```T1, T2, T3```?  
**Ответ:**  
T1: В качестве ```T1``` допустимо использовать любый непримитивные (не базовые) типы.  
T2: Т.к. ```Т2``` расширяет класс ```Number``` в качестве ```Т2``` допустимо использовать только подклассы класса ```Number```.  
T3: Т.к. ```T3``` расширяет класс ```Object``` в качестве ```T3``` допустимо использовать любые непримитивные (не базовые) типы.  

(5)  Дан код:
```java
class Gen1 <T> { … }
class Gen2 <T extends Object> { … }
class Runner {
private final static Gen1<Object> g11 = new Gen1<>();
private final static Gen1 g12 = new Gen1();
private final static Gen2<Object> g21 = new Gen2<>();
private final static Gen2 g22 = new Gen2();
...
}
```
1: В чем различие объявления классов ```Gen1``` и ```Gen2```?    
2: Есть ли преимущество в объявлении ```g11``` по сравнению с ```g12?``` Обоснуйте ответ.  
3: Есть ли преимущество в объявлении ```g21``` по сравнению с  ```g12```? Обоснуйте ответ.  
4: В каком случае используется второй способ ```(g12, g22)```?  
**Ответ:**  
1: ```Gen1``` и ```Gen2``` не имеют никакого различия, так как ```<T>``` и ```<T extends Object>``` эквивалентны. ```<T>``` по умолчанию предполагает класс ```T``` наследуется от класса ```Object```  
2: Да, если фактический аргумент типа опущен, вы создаете необработанный тип. В нашем случае это ```g12``` 
Необработанные типы ```Raw types``` обходят проверки универсального типа, откладывая обнаружение небезопасного кода во время выполнения. 
Следовательно, нам следует избегать использования необработанных типов. Таким образом ```g12``` "условно" отказался от проверки универсального типа, 
в то время как ```g11``` явно сказал компилятору, что он способен содержать объекты любого типа.  
3: Да (смотреть ответ #6). ```g12``` Необработанный тип ```Raw type```.  
4: Использование необработанных типов допускается только в качестве уступки совместимости устаревшего кода.
Из-за непатентованного универсального кода Java есть два исключения, где необработанные типы должны использоваться в новом коде:  
а) Литералы класса, например ```List.class```, не ```List<String>.class```  
б) ```instanceof``` операнд, например ```o instanceof Set```, не ```o instanceof Set<String>```     
**Источник:**  И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 91  
https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html
https://qastack.ru/programming/2770321/what-is-a-raw-type-and-why-shouldnt-we-use-it  

(6) Дан код:
```java
class SubInfo extends Info { … }
class Gen1 <T> { … }
class Gen2 <T extends Info> { … }
```
1: Является ли декларация ```Gen1<Info>``` подклассом ```Gen2<Info>```?  
2: Является ли декларация ```Gen1<SubInfo>``` подклассом ```Gen1<Info>```?  
3: Является ли декларация ```Gen2<SubInfo>``` подклассом ```Gen2<Info>```?     
**Ответ:**  
1: Нет , общим родителем ```Gen2<Info>``` и ```Gen1<Info>``` является класс ```Object```  
2: Нет, Учитывая два конкретных типа ```SubInfo``` и ```Info``` ,
```Gen1<Info>``` не имеет отношения к  ```Gen1<SubInfo>``` , независимо от того , связаны ли
```SubInfo``` и ```Info```. Общим родителем ```Gen1<SubInfo>``` и ```Gen1<Info>``` является ```Object```.  
3: Нет (смотреть ответ #10)   
Во всех случаях ```Gen2<> и Gen1<>``` являются подклассами класса ```Object```  
**Источник:** https://docs.oracle.com/javase/tutorial/java/generics/inheritance.html  

(7) Почему нельзя вызвать конструктор ```generic-типа```?  
**Ответ:** Для generic-типов существует целый ряд ограничений. 
Например, невозможно выполнить явный вызов конструктора generic-типа:
```java 
class FailedOne <T> {
private T value = new T();
}
```
так как компилятор не знает, какой конструктор может быть вызван и какой
объем памяти должен быть выделен при создании объекта.  
**Источник:** И.Н. Блинов В.С. Романчик Java from EPAM : учеб.-метод. пособие (Четыре четверти, 2020.) стр. 91

(8) Почему нельзя создать ```generic-поле```?  
**Ответ:** Статическое поле класса - это переменная уровня класса, совместно используемая всеми нестатическими объектами класса. 
Следовательно, статические поля параметров типа не допускаются.  
**Источник:** https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html  

(9) Почему статический метод не может иметь ```generic-параметр```?  
**Ответ:** Если метод статический, то унаследовать параметр типа от класса он не может. 
Это вызвано тем, что параметр типа привязывается к конкретному объекту при его создании, 
а статический метод не привязан к конкретному объекту, он привязан к классу в целом. 
В случае статического метода параметр типа нужно указывать непосредственно перед объявлением метода:  
```java 
public class A {
    public static <T> void doSth(T t) {
        System.out.println(t.getClass().getName());
    }
}

A.doSth("abc");         // выведет java.lang.String
A.doSth(123);           // выведет java.lang.Integer
```
В этом случае тип T определяется в момент вызова статического метода по типу передаваемого аргумента.  

(10) Предложите более эффективную запись данного кода:
```java
<T> void make1(Gen <T extends Object> gen) { … }
<T, S extends T> void make2(Info<T> info1, Info<S> info2) { … }
```  
**Ответ:** 
```java
<T> void make1(Gen <?> gen) {...}
<T> void make2(Info<T> info1, Info<? extends T> info2) { … }
```

(11) Дан код:
```java
class Info {
public <T1> Info() { … }
public <T2> Info(T2 t2) { … }
public <T1> void make1(T1 t1) { … }
public <T3> void make2() { … }
}
```
Создайте какой-либо экземпляр класса Info   
 конструктором без аргументов,  
 конструктором с аргументом.  
 Синтаксически правильно вызовите методы make1() и make2().  
**Ответ:**  
Т.к. в данном примере сам класс ```Info``` не определен как обобщенный, а конструктор определен таковым, создание экземляров класса ```Info``` будет выглядеть как в примере ниже.  
В данном примере методы ```make1``` и ```make2``` определены как обобщенные их синтаксически правильный вызов будет выглядеть следующим образом:  
```java
class Info {
public <T1> Info() { … }
public <T2> Info(T2 t2) { … }
public <T1> void make1(T1 t1) { … }
public <T3> void make2() { … }

    public static void main(String[] args) {
        Info info1 = new <T1>Info();
        Info info2 = new Info(new T2());
        String making = "I'm making something";
        info1.make1(making); //implicit generic <String>
        info2.make2();
    }
}
```
Как можно понять из примера ```info2``` может вызывать метод ```make()``` не указывая тип ```<String>```  т.к. он определяется неявно с помощью строки ```making``` переданной в метод.  
**Источник:**  https://metanit.com/java/tutorial/3.11.php  

(12) Поясните данный код:
```java
static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)
```  
**Ответ:** Это универсальный статический метод, параметрезированный```Multiple Bounds``` – множественные ограничения. Записывается через символ ```&```, 
то есть мы говорим, что тип, представленный переменной типа ```T```, должен быть ограничен сверху классом 
```Object``` и интерфейсом ```Comparable```. Запись ```Object & Comparable<? super T>>``` образует тип 
пересечения ```Multiple Bounds```. Первое ограничение — в данном случае ```Object``` — используется для ```erasure```, 
процесса затирания типов. Его выполняет компилятор на этапе компиляции.  
**Источник:** https://habr.com/ru/company/sberbank/blog/416413/

